# =============================================================================
# Centaur Flights, 2013; Manassas, VA, Test Flights.
# Flight HCI.tma.
# =============================================================================


# -----------------------------------------------------------------------------
# Partition 1: Main Line Code
# -----------------------------------------------------------------------------

### Need to verify switches before we use them
# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised), most algo processing is suspended.
# If both switches are On (1, raised) Shutdown begins immediately.
# (IOSwS & 3) == 3 - Flight Mode (both switches up)

%{
  #include "msg.h"
%}

# INITIALIZE
State Init {
       > Telemetry Start
  +1   > Fail Light Off
       > Panel Keypad Backlight Off
       > Panel Display Text \\xFE\\x47\\x00\\x04
  +2   Validate Standby;
}

# WAIT 
State Standby {
        depending on (TAKE_DATA) { Validate Record; }
        depending on (LAND)      { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
#       depending on (MQCLI_Fail) { Validate Shutdown; }
#       depending on (CQCLI_Fail) { Validate Shutdown; }
        depending on (BAT_SPAN_Fail) { Validate Shutdown; }
        depending on (Inverter_Fail) { Validate Shutdown_Fast; }
}

# RECORD  
State Record {
        depending on (LAND)      { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
#       depending on (MQCLI_Fail) { Validate Shutdown; }
#       depending on (CQCLI_Fail) { Validate Shutdown; }
#       depending on (BAT_SPAN_Fail) { Validate Shutdown; }
        depending on (Inverter_Fail) { Validate Shutdown_Fast; }
        "In Record";
}

# SHUTDOWN
State Shutdown {
 +1   > Panel Display Text \\nShutting Down...
      Hold until valid (MINI_Is_Shutdown, CO2_Is_Shutdown,
        Pump_Is_Shutdown, Inverter_Is_Shutdown,
        SampleHtr_Shutdown) or 5:00;
 +2   > Panel Display Text Done
      > Fail Light On
      > Quit
}

State Shutdown_Fast {
      > Panel Display Text \\nFast Shutdown...
  +4  > Panel Display Text Done
      > Fail Light On
      > Quit
}

# -----------------------------------------------------------------------------
# Partition 2: Flight Mode
# -----------------------------------------------------------------------------

Partition

# This partition looks for pilot panel switch position and flight sensors to decide state of instrument. 
# IN Flight, Take Data, Land, Calibrate. 
# (ON_GROUND, OFF_GROUND, IN_AIR). \

%{ /* Altitude definitions */
    int using_swp = 0;
%}

State In_FLIGHT {
  { using_swp = 0; }
  { if ((using_swp == SWS_TAKE_DATA) || (PP_Land_Req == 0))
      Validate TAKE_DATA;
  }
  > Panel Data LED Off
}

State TAKE_DATA {
  { if ((using_swp == SWS_LAND) || (using_swp == 0 && PP_Land_Req))
      Validate LAND;
  }
  > Panel Data LED On
}

State LAND {
  > Panel Data LED Off
}

#----------------------------------------------------------------
# Partition 3: Sample Heater Control
#----------------------------------------------------------------
Partition
State SampleHtr_Init {
     Depending on (Shutdown) { Validate SampleHtr_Shutdown; }
     Depending on (Record) { Validate SampleHtr_Watch; }
}

State SampleHtr_Watch NoLog {
      Depending on (Shutdown) { Validate SampleHtr_Shutdown; }
   +5 > HK Set Sample Heater Temp Setpoint 1.39
   +1 > HK Sample Htr Ctl On
      Hold until (convert(SH_CT) > 1.45);
   +1 > HK Sample Htr Ctl Off
      Hold until (convert(SH_CT) < 1.35);
   +1 Validate SampleHtr_Watch;
}

State SampleHtr_Shutdown {
      > HK Sample Htr Ctl Off
}

#----------------------------------------------------------------
# Partition 4: Mini Methane Control
#----------------------------------------------------------------
Partition

%{
  int MINI_Ready_To_Calibrate;
%}

State MINI_Init {
   +1 > MINI Pressure Reg Off
      Depending on (Shutdown) { Validate MINI_Shutdown; }
      Depending on (Record) { Validate MINI_Start; }
}

State MINI_Start {
      Depending on (Shutdown) { Validate MINI_Shutdown; }
   +5 Validate MQCL_SelectICOSandRun;
   +5 Hold until valid (MQCL_Watch, Pump_Watch);
   +1 Validate MINI_Sample;
}

State MINI_Sample {
       Depending on (Shutdown) { Validate MINI_Shutdown; }
       { if (!MM_Pump_S || !MM_Pump_DS) Validate MINI_Fill_To_Ambient; }
       > MINI Set Cell Pressure Setpoint 40
       Hold until (convert(MCelLP) < 10);
    +1 > MINI Pressure Reg On
    +1 Validate MQCL_SelectRingandRun;
 +1:00 Validate MQCL_SelectICOSandRun;
       Hold Until (SWStat == SWS_TIMEWARP) or 30:00;
       Validate MINI_Calibrate;
}

State MINI_Calibrate {
     Depending on (Shutdown) { Validate MINI_Shutdown; }
     { if (!MM_Pump_S || !MM_Pump_DS) Validate MINI_Fill_To_Ambient; }
     { MINI_Ready_To_Calibrate = 1; }

     Depending on (1Hz) {
       if ( MINI_Ready_To_Calibrate == 0 )
         Validate MINI_End_Calibrate;
     }
}

State MINI_End_Calibrate {
     Depending on (Shutdown) { Validate MINI_Shutdown; }

       > MINI Set Cell Pressure Setpoint 40
       Hold until (convert(MCelLP) < 10);
    +1 > MINI Pressure Reg On
   +20 Validate MQCL_NC_1;
    +1 Hold until valid (MQCL_Watch);
   +10 Validate MQCL_Stop;
       Hold Until Valid (MQCL_Idle);
    +1 > MINI Pressure Reg Off
       Validate MINI_Sample;
}

State MINI_Fill_to_Ambient {
    { MINI_Ready_To_Calibrate = 0; }
    > MINI Set Cell Pressure Setpoint 120
    > MINI Pressure Reg On
    { if (MM_Pump_S && MM_Pump_DS) Validate MINI_Sample; }
    Depending on (Shutdown) { Validate MINI_Shutdown; }
}

State MINI_Shutdown {
     > MINI Pressure Reg Off
  +1 Hold until valid (MQCL_Is_Shutdown);
     Validate MINI_Is_Shutdown;
}

State MINI_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 5: CO2 Control
#----------------------------------------------------------------
Partition

%{
  int CO2_Ready_To_Calibrate;
%}

State CO2_Init {
   +1 > CO2 Pressure Reg Off
      Depending on (Shutdown) { Validate CO2_Shutdown; }
      Depending on (Record) { Validate CO2_Start; }
}

State CO2_Start {
      Depending on (Shutdown) { Validate CO2_Shutdown; }
   +5 Validate CQCL_SelectICOSandRun;
   +5 Hold until valid (CQCL_Watch, Pump_Watch);
   +1 Validate CO2_Sample;
}

State CO2_Sample {
       Depending on (Shutdown) { Validate CO2_Shutdown; }
       { if (!C_Pump_S || !C_Pump_DS) Validate CO2_Fill_to_Ambient; }
       > CO2 Set Cell Pressure Setpoint 40
       Hold until (convert(CCelLP) < 10);
    +1 > CO2 Pressure Reg On
       Hold until (SWStat == SWS_TIMEWARP) or 30:00;
       Validate CO2_Calibrate;
}

State CO2_Calibrate {
    Depending on (Shutdown) { Validate CO2_Shutdown; }
    { if (!C_Pump_S || !C_Pump_DS) Validate CO2_Fill_to_Ambient; }
    { CO2_Ready_To_Calibrate = 1; }
   
    Depending on (1Hz) {
      if ( CO2_Ready_To_Calibrate == 0 ) Validate CO2_End_Calibrate;
    }
}

State CO2_End_Calibrate {
        > CO2 Set Cell Pressure Setpoint 40
        Hold until (convert(CCelLP) < 10);
    +1  > CO2 Pressure Reg On
   +20  Validate CQCL_NC_1;
    +1  Hold until valid (CQCL_Watch);
   +10  Validate CQCL_Stop;
        Hold Until Valid (CQCL_Idle);
        Validate CQCL_SelectICOSandRun;
    +1  > CO2 Pressure Reg Off
        Validate CO2_Sample;
}

State CO2_Fill_to_Ambient {
    { CO2_Ready_To_Calibrate = 0; }
    > CO2 Set Cell Pressure Setpoint 120
    > CO2 Pressure Reg On
    { if (C_Pump_S && C_Pump_DS) Validate CO2_Sample; }
    Depending on (Shutdown) { Validate CO2_Shutdown; }
}

State CO2_Shutdown {
     > CO2 Pressure Reg Off
  +1 Hold until valid (CQCL_Is_Shutdown);
     Validate CO2_Is_Shutdown;
}

State CO2_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 6: Mini Methane Laser Control 7.7um QCL ICOS
#----------------------------------------------------------------
Partition
%{
  int num_MQCL_recovers = 0;
  #define M_LOW_CURRENT 0.02
  #define MQCL_TEMP_LIMIT 1.3
  #define MQCL_TEMP_OK(x,y) (x > MQCL_TEMP_LIMIT && fabs(x - y) < 0.2)
%}
# Mini Starting and Stopping

State MQCL_Init {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
  +1  > SSP_M Stop
  +1  Validate MQCLI_Stop;
      Hold until valid (MQCLI_Idle);
      Validate MQCL_Idle;
}

State MQCL_Idle {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
}

State MQCL_Start {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    Hold until ( SSP_M_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP_M Not Ready in MQCL_Start" );
      Validate MQCL_SSP_M_Recover;
    }
    Hold until ( MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ) or 10
    else Validate MQCL_Out_TSpec;
    Hold until valid (MQCLI_Idle) or 2
    else Validate MQCLI_Stop;
    Hold until valid (MQCLI_Idle);
 +1 > SSP_M Start
    Hold until ( SSP_M_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in MQCL_Start" );
      Validate MQCL_SSP_M_Recover;
    }
    Validate MQCLI_Run;
    Hold until (SSP_M_Status == SSP_STATUS_TRIG &&
                convert(MLasI) > M_LOW_CURRENT) or 20
    else Validate MQCL_SSP_M_Recover;
    { num_MQCL_recovers = 0; }
    Validate MQCL_Watch;
}

# MQCL_NC_1: stop SSP, set NCoadd to 1 and restart SSP without shutting down QCLI
State MQCL_NC_1 {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
   +1 > SSP_M Stop
      Hold until (SSP_M_Status == SSP_STATUS_READY) or 2 else {
        nl_error( 2, "SSP_M Not Ready in MQCL_NC_1" );
        Validate MQCL_SSP_M_Recover;
      }
   +1 > SSP_M Set NCoadd 1
      > SSP_M Start
      Hold until (SSP_M_Status == SSP_STATUS_ARMED ||
                  SSP_M_Status == SSP_STATUS_TRIG) or 20 else {
        nl_error(2, "Not starting in MQCL_NC_1");
        Validate MQCL_SSP_M_Recover;
      }
   +1 Validate MQCL_Watch;
}

State MQCL_Watch NoLog {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    { if ( SSP_M_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP_M Went Ready Spontaneously" );
        Validate MQCL_SSP_M_Recover;
      }
    }
    hold until ( SSP_M_Status != SSP_STATUS_TRIG ||
         !MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ||
         convert(MLasI) <= M_LOW_CURRENT );
    hold until ( SSP_M_Status == SSP_STATUS_TRIG &&
         MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) &&
         convert(MLasI) >= M_LOW_CURRENT) or 2
    else Validate MQCL_Watch_Recover;
    Validate MQCL_Watch;
}

State MQCL_Watch_Recover NoLog {  
  { if (!MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)))
      Validate MQCL_Out_TSpec;
    else if (convert(MLasI) <= M_LOW_CURRENT)
      Validate MQCL_Out_Spec;
    else if (SSP_M_Status != SSP_STATUS_TRIG)
      Validate MQCL_SSP_M_Recover;
    else Validate MQCL_Watch;
  }
}

State MQCL_SSP_M_Recover NoLog {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    { if ( ++num_MQCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_MQCL_recovers. Trying reset" );
        num_MQCL_recovers = 0;
        Validate MQCLI_Stop_Reset;
      }
    }
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 10
    else Validate MQCL_SSP_M_Not_Talking;
 +2 Validate MQCLI_Stop;
    Hold until valid (MQCLI_Idle);
    Validate MQCL_Start;
}

State MQCL_SSP_M_Not_Talking {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    { if ( ++num_MQCL_recovers > 20 ) Validate MQCL_Fail; }
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 10
    else Validate MQCL_SSP_M_Not_Talking;
    Validate MQCL_SSP_M_Recover;
}

State MQCL_Fail {
    > Log Laser MQCL Has Failed
 +1 Validate MQCL_Shutdown;
}

State MQCL_Shutdown {
    > SSP_M Stop
 +1 Validate MQCLI_Stop;
    Hold until valid (MQCLI_Idle) or 20;
    > Log Laser MQCL Has Shutdown
    > MINI Laser TEC Off
    Validate MQCL_Is_Shutdown;
}

State MQCL_Is_Shutdown {}

State MQCL_Out_Spec {
    Validate MQCLI_Stop;
    Hold until Valid (MQCLI_Idle);
    Validate MQCL_Start;
}

State MQCL_Out_TSpec {
    Validate MQCLI_Stop;
 +1 > MINI Laser TEC Off
#+1 > Reprogram CB2 DACs
 +2 > MINI Laser TEC On
    Hold until valid (MQCLI_Idle);
    Hold until ( MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ) or 10
    else Validate MQCL_Out_TSpec;
 +1 Validate MQCL_Start;
}

State MQCL_Stop {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
 +1 Validate MQCLI_Stop;
    Hold until valid (MQCLI_Idle);
    Validate MQCL_Idle;
}

#Running Waveforms

State MQCL_SelectICOSandRun {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in M3Df_600Hz" ); }
    Hold until valid (MQCLI_Idle) or 2
    else Validate MQCLI_Stop;
    Hold until valid (MQCLI_Idle);
 +1 > MINI Set Laser TEC Temp Setpoint 1.38
 +1 > MINI Laser TEC On
 +5 > Select QCLI_M Waveform M3Df_600Hz
 +2 Validate MQCL_Start;
}

State MQCL_SelectRingandRun {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in M3Df_rRamp" ); }
    Hold until valid (MQCLI_Idle) or 2
    else Validate MQCLI_Stop;
    Hold until valid (MQCLI_Idle);
 +1 > MINI Set Laser TEC Temp Setpoint 1.38
 +1 > MINI Laser TEC On
 +5 > Select QCLI_M Waveform M3Df_rRamp
 +1 > SSP_M Set NSample 500
 +2 Validate MQCL_Start;
}

#----------------------------------------------------------------
# Partition 6a: MINI QCLI Control
#----------------------------------------------------------------
Partition
%{
  int num_MQCLI_recovers = 0;
%}

State MQCLI_Idle {}

State MQCLI_Run {
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCLI_Start_Reset;
    > QCLI_M Run
    { num_MQCLI_recovers = 0;
      Validate MQCLI_Running;
    }
}

State MQCLI_Running {
}

State MQCLI_Start_Reset {
    { if ( ++num_MQCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_MQCLI_recovers in MQCLI_Start_Reset" );
        Validate MQCLI_Fail;
      }
    }
    > MINI QCLI Reset On
 +1 > MINI QCLI Reset Off
    Validate MQCLI_Run;
}

State MQCLI_Stop {
      > QCLI_M Stop
      Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
      else > QCLI_M clear errors
      Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
      else Validate MQCLI_Stop_Reset;
      Validate MQCLI_Idle;
}

State MQCLI_Stop_Reset {
    { if ( ++num_MQCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_MQCLI_recovers in MQCLI_Stop_Reset" );
        Validate MQCLI_Fail;
      }
    }
    > MINI QCLI Reset On
 +1 > MINI QCLI Reset Off
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCLI_Stop_Reset;
    { num_MQCLI_recovers = 0;
      ci_sendfcmd( 0, "Select QCLI_M Waveform Number %d\n", QCLI_M_Wave );
      Validate MQCLI_Idle;
    }
}

State MQCLI_Fail {
    { nl_error( 2, "M_QCLI Not Responding" ); }
 +2:00 Validate MQCLI_Stop_Reset;
}

State MQCLI_Shutdown {}

#----------------------------------------------------------------
# Partition 7: CO2 Laser Control 4.3um QCL ICOS
#----------------------------------------------------------------
Partition

%{
 int num_CQCL_recovers=0;
 #define C_LOW_CURRENT 0.02
 #define CQCL_TEMP_LIMIT 1.3
 #define CQCL_TEMP_OK(x,y) (x > CQCL_TEMP_LIMIT && fabs(x - y) < 0.2)
%}

# CO2 Starting and Stopping

State CQCL_Init {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
  +1  > SSP_C Stop
  +1  Validate CQLI_Stop;
      Hold until valid (CQCLI_Idle);
      Validate CQCL_Idle;
}

State CQCL_Idle {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
}

State CQCL_Start {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    Hold until ( SSP_C_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP_C Not Ready in CQCL_Start" );
      Validate CQCL_SSP_C_Recover;
    }
    Hold until ( CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) ) or 10
    else Validate CQCL_Out_TSpec;
    Hold until valid (CQCLI_Idle) or 2
    else Validate CQCLI_Stop;
    Hold until valid (CQCLI_Idle);
 +1 > SSP_C Start
    Hold until ( SSP_C_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in CQCL_Start" );
      Validate CQCL_SSP_C_Recover;
    }
    Validate CQCLI_Run;
    Hold until (SSP_C_Status == SSP_STATUS_TRIG &&
                convert(CLasI) > C_LOW_CURRENT ) or 20
    else Validate CQCL_SSP_C_Recover;
    { num_CQCL_recovers = 0; }
    Validate CQCL_Watch;
}

# CQCL_NC_1: stop SSP, set NCoadd to 1 and restart SSP without shutting down QCLI
State CQCL_NC_1 {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
   +1 > SSP_C Stop
      Hold until (SSP_C_Status == SSP_STATUS_READY) or 2 else {
        nl_error( 2, "SSP_C Not Ready in CQCL_NC_1" );
        Validate MQCL_SSP_C_Recover;
      }
   +1 > SSP_C Set NCoadd 1
      > SSP_C Start
      Hold until (SSP_C_Status == SSP_STATUS_ARMED ||
                  SSP_C_Status == SSP_STATUS_TRIG) or 20 else {
        nl_error(2, "Not starting in CQCL_NC_1");
        Validate CQCL_SSP_C_Recover;
      }
   +1 Validate CQCL_Watch;
}

State CQCL_Watch NoLog {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    { if ( SSP_C_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP_C Went Ready Spontaneously" );
        Validate CQCL_SSP_C_Recover;
      }
    }
    hold until ( SSP_C_Status != SSP_STATUS_TRIG ||
         !CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) ||
         convert(CLasI) <= C_LOW_CURRENT );
    hold until ( SSP_C_Status == SSP_STATUS_TRIG &&
         CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) &&
         convert(CLasI) >= C_LOW_CURRENT ) or 2
    else Validate CQCL_Watch_Recover;
    Validate CQCL_Watch;
}

State CQCL_Watch_Recover {
    {
      if (!CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)))
        Validate CQCL_Out_TSpec;
      else if (convert(CLasI) <= C_LOW_CURRENT)
        Validate CQCL_Out_Spec;
      else if (SSP_C_Status != SSP_STATUS_TRIG)
        Validate CQCL_SSP_C_Recover;
      else Validate CQCL_Watch;
    }
}

State CQCL_SSP_C_Recover NoLog {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
    { if ( ++num_CQCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_CQCL_recovers. Trying reset" );
        num_CQCL_recovers = 0;
        Validate CQCL_QCLI_C_Reset;
      }
    }
    Hold until ( SSP_C_Status == SSP_STATUS_READY ) or 10
    else Validate CQCL_SSP_C_Not_Talking;
 +2 Validate CQCLI_Stop
    Hold until valid (CQCLI_Idle);
    Validate CQCL_Start;
}

State CQCL_SSP_C_Not_Talking {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
    { if ( ++num_CQCL_recovers > 20 ) Validate CQCL_Fail; }
    Hold until ( SSP_C_Status == SSP_STATUS_READY ) or 10
    else Validate CQCL_SSP_C_Not_Talking;
    Validate CQCL_SSP_C_Recover;
}

State CQCL_Fail {
    > Log Laser CQCL Has Failed
 +1 Validate CQCL_Shutdown;
}

State CQCL_Shutdown {
    > SSP_C Stop
 +1 Validate QCLI_Stop
    Hold until valid (CQLI_Idle) or 20;
    > Log Laser CQCL Has Shutdown
    > CO2 Laser TEC Off
    Validate CQCL_Is_Shutdown;
}

State CQCL_Is_Shutdown {}

State CQCL_Out_Spec {
    Validate CQCLI_Stop;
    Hold until valid (CQCLI_Idle);
 +1 Validate CQCL_QCLI_C_Recover;
}

State CQCL_Out_TSpec {
    Validate CQCLI_Stop;
 +1 > CO2 Laser TEC Off
 +5 > CO2 Laser TEC On
    Hold until valid (CQCLI_Idle);
    Hold until ( CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) ) or 10
    else Validate CQCL_Out_TSpec;
 +1 Validate CQCL_Start;
}

State CQCL_Stop {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
 +1 Validate QCLII_Stop;
    Hold until valid (CQCLI_Idle);
    Validate CQCL_Idle;
}

#Running Waveforms

State CQCL_SelectICOSandRun {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
    Hold until ( SSP_C_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in C2Cd_800Hz" ); }
    Hold until valid (CQCLI_Idle) or 2
    else Validate CQCLI_Stop;
    Hold until valid (CQCLI_Idle);
 +1 > CO2 Set Laser TEC Temp Setpoint 1.45
 +1 > CO2 Laser TEC On
 +5 > Select QCLI_C Waveform C2Cd_800Hz
 +2 Validate CQCL_Start;
}

#----------------------------------------------------------------
# Partition 7a: CO2 QCLI Control
#----------------------------------------------------------------
Partition
%{
  int num_CQCLI_recovers = 0;
%}

State CQCLI_Idle {}

State CQCLI_Run {
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else > QCLI_C clear errors
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else Validate CQCLI_Start_Reset;
    > QCLI_C Run
    { num_CQCLI_recovers = 0;
      Validate CQCLI_Running;
    }
}

State CQCLI_Running {
}

State CQCLI_Start_Reset {
    { if ( ++num_CQCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_CQCLI_recovers in CQCLI_Start_Reset" );
        Validate CQCLI_Fail;
      }
    }
    > CO2 QCLI Reset On
 +1 > CO2 QCLI Reset Off
    Validate CQCLI_Run;
}

State CQCLI_Stop {
      > QCLI_C Stop
      Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
      else > QCLI_C clear errors
      Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
      else Validate CQCLI_Stop_Reset;
      Validate CQCLI_Idle;
}

State CQCLI_Stop_Reset {
    { if ( ++num_CQCLI_recovers > 20 ) {
        nl_error( 2,"Exceeded num_CQCLI_recovers in CQCLI_Stop_Reset" );
        Validate CQCLI_Fail;
      }
    }
    > CO2 QCLI Reset On
 +1 > CO2 QCLI Reset Off
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else > QCLI_C clear errors
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else Validate CQCLI_Stop_Reset;
    { num_CQCLI_recovers = 0;
      ci_sendfcmd( 0, "Select QCLI_C Waveform Number %d\n", QCLI_C_Wave );
      Validate CQCLI_Idle;
    }
}

State CQCLI_Fail {
    { nl_error( 2, "CO2 QCLI Not Responding" ); }
 +2:00 Validate CQCLI_Stop_Reset;
}

State CQCLI_Shutdown {}

#----------------------------------------------------------------
# Partition 8: Calibration Logic 
#----------------------------------------------------------------
Partition

State Calibrate_Logic {
  Depending on (1Hz) {
    if ( MINI_Ready_To_Calibrate == 1 )
      Validate Calibrate_MINI; 
    else if ( CO2_Ready_To_Calibrate == 1 )
      Validate Calibrate_CO2;
  }
}

State Calibrate_MINI {
{ Cell_Ctrl = 0; }  
   +1 > MINI Pressure Reg Off 
   +1 > MINI Gas Valve Open
   +1 Validate GasDeck_PI_Init;
      Hold until (MINI_Ready_To_Calibrate == 0) or 2:00;
      Validate GasDeck_Close;
      { MINI_Ready_To_Calibrate = 0; }
   +9 Validate Calibrate_Logic;
}

State Calibrate_CO2 {
{ Cell_Ctrl = 1; }
   +1 > CO2 Pressure Reg Off 
   +1 > CO2 Gas Valve Open
   +1 Validate GasDeck_PI_Init;
      Hold until (CO2_Ready_To_Calibrate == 0) or 2:00;
      Validate GasDeck_Close;
      { CO2_Ready_To_Calibrate = 0; }
   +9 Validate Calibrate_Logic;
}

#----------------------------------------------------------------
# Partition 9: Gas Deck Pressure Control
#----------------------------------------------------------------
Partition

%{
  double P_sum = 0., Gp, Gi;
  int Cell_Ctrl;
  #define MAX_CAL_BITS 32768
  #include <math.h> /* for fabs */
%}

State GasDeck_Init {
     > Gas Deck Flow Controller Closed On
     > Gas Deck Valve Closed
     > MINI Gas Valve Closed
     > CO2 Gas Valve Closed
     > Gas Deck Set Gas Flow Setpoint 0
 +1  Validate GasDeck_Idle;
}

State GasDeck_Idle {
}

State GasDeck_PI_Init {
  { P_sum = 0; Gp = 300; Gi = 90; }
     > Gas Deck Set Gas Flow Setpoint 0
     > Gas Deck Flow Controller Closed Off
  +1 > Gas Deck Valve Open
  +2 Validate GasDeck_PI;
}

State GasDeck_PI {
  { double P, P_set, P_diff, dstep; 
    P = Cell_Ctrl ? convert(CCelP):convert(MCelP);
    P_set = Cell_Ctrl ? convert(CCelPSt):convert(MCelPSt);
    P_diff = P_set - P;
    P_sum += P_diff * Gi;
    if ( P_sum > MAX_CAL_BITS )
      P_sum = MAX_CAL_BITS;
    else if ( P_sum < 0 ) P_sum = 0;
    dstep = P_diff * Gp + P_sum;
    if (dstep<0) dstep = 0;
    else if (dstep > MAX_CAL_BITS) dstep = MAX_CAL_BITS;
    dstep = dstep / 32768 * 5;
    ci_sendfcmd(2, "Gas Deck Set Gas Flow Setpoint %.3lf\n", dstep);
  }
}

State GasDeck_Fill_MINI_Cell {
  Hold Until ( convert(MCelHP) < 740 ) or 1
     else  Validate GasDeck_Close;
  +1 > CO2 Gas Valve Closed
  +1 > MINI Gas Valve Open
  +1 > MINI Exhaust Valve Closed
     > Gas Deck Set Gas Flow Setpoint 0
     > Gas Deck Flow Controller Closed Off
  +1 > Gas Deck Valve Open
  +1 > Gas Deck Set Gas Flow Setpoint .75
  Hold Until ( convert(MCelHP) > 500 ) or 2:00;
  +1 > Gas Deck Set Gas Flow Setpoint 0.4
  Hold Until ( convert(MCelHP) > 700 ) or 2:00;
  +1 > Gas Deck Set Gas Flow Setpoint 0.1
  Hold Until ( convert(MCelHP) > 760 ) or 2:00;
  Validate GasDeck_Close;
}

State GasDeck_Fill_CO2_Cell {
  Hold Until ( convert(CCelHP) < 740 ) or 1
     else  Validate GasDeck_Close;
  +1 > MINI Gas Valve Closed
  +1 > CO2 Gas Valve Open
  +1 > CO2 Exhaust Valve Closed
     > Gas Deck Set Gas Flow Setpoint 0
     > Gas Deck Flow Controller Closed Off
  +1 > Gas Deck Valve Open
  +1 > Gas Deck Set Gas Flow Setpoint 0.32
  Hold Until ( convert(CCelHP) > 600 ) or 2:00;
  +1 > Gas Deck Set Gas Flow Setpoint 0.2
  Hold Until ( convert(CCelHP) > 700 ) or 2:00;
  +1 > Gas Deck Set Gas Flow Setpoint 0.05
  Hold Until ( convert(CCelHP) > 760 ) or 2:00;
  Validate GasDeck_Close;
}

State GasDeck_Close {
     > Gas Deck Flow Controller Closed On
  +1 > Gas Deck Valve Closed
  +1 > MINI Gas Valve Closed
     > CO2 Gas Valve Closed
  +1 Validate GasDeck_Idle;
}

#---------------------------------------------------------------
# Partition 9.5: GasDeck Shutdown
#---------------------------------------------------------------
Partition

State GasDeck_WaitForShutdown {
     Depending on (Shutdown) { Validate GasDeck_Shutdown; }
}

State GasDeck_Shutdown {
  +1 Validate GasDeck_Close;
      Hold until valid (GasDeck_Idle);
  +1 Validate GasDeck_Fill_MINI_Cell;
     Hold until valid (GasDeck_Idle);
  +1 Validate GasDeck_Fill_CO2_Cell;
      Hold until valid (GasDeck_Idle);
  +1 Validate GasDeck_Is_Shutdown;
}

State GasDeck_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 10: Pumpkin Troll
#----------------------------------------------------------------
Partition
%{
 #define PUMP_TEMP_HOT 50
 #define PUMP_TEMP_OK(x) (x < PUMP_TEMP_HOT)
 int Pump_Ground_Power = 0;
%}

State Pump_Init {
    > CO2 Exhaust Valve Closed
    > MINI Exhaust Valve Closed
 +1 > CO2 Scroll Pump Off
 +1 > MINI Scroll Pump Off
    Hold until valid (Inverter_On) or 5
    else Validate Pump_Init_Inverter_Off;
    Validate Pump_Init_Ready;
}

State Pump_Init_Inverter_Off {
    Depending on (Shutdown) { Validate Pump_Shutdown; }
    Hold until valid (Inverter_On);
    Validate Pump_Init_Ready;
}

State Pump_Init_Ready {
    Depending on (Inverter_Off) { Validate Pump_Init_Inverter_Off; }
    Depending on (Shutdown) { Validate Pump_Shutdown; }
    Depending on (Record) { Validate Pump_Start; }
}

State Pump_Start {
       Depending on (Shutdown) { Validate Pump_Shutdown; }
       Depending on (Inverter_Off) { Validate Pump_Inverter_Off; }
       Depending on (Inverter_Fail) { Validate Pump_Inverter_Off; }
       # Don't necessarily need to wait here
       Depending on (Pump_Cool_Watch) { Validate Pump_Turn_On; }
       Depending on (Pump_Cool_Cold) { Validate Pump_Turn_On; }
       Depending on (Pump_Cool_HiP_Watch) { Validate Pump_Turn_On; }
}

State Pump_Turn_On {
       Depending on (Shutdown) { Validate Pump_Shutdown; }
       Depending on (Inverter_Off) { Validate Pump_Inverter_Off; }
       Depending on (Inverter_Fail) { Validate Pump_Inverter_Off; }
    +5 > CO2 Scroll Pump On
   +10 > MINI Scroll Pump On
   +10 > CO2 Exhaust Valve Open
    +1 > MINI Exhaust Valve Open
       Validate Pump_Watch;
}

State Pump_Watch Nolog {
      Depending on (Shutdown) { Validate Pump_Shutdown; }
      Depending on (Inverter_Off) { Validate Pump_Inverter_Off; }
      Depending on (Inverter_Fail) { Validate Pump_Inverter_Off; }
      hold until ( !PUMP_TEMP_OK(convert(CPmpT)) ||
           !PUMP_TEMP_OK(convert(MPmpT)) );
      hold until ( PUMP_TEMP_OK(convert(CPmpT)) &&
           PUMP_TEMP_OK(convert(MPmpT)) ) or 5
      else Validate Pump_Hot;
      Validate Pump_Watch;
}

State Pump_Hot {
      Depending on (Shutdown) { Validate Pump_Shutdown; }
      Depending on (Inverter_Off) { Validate Pump_Inverter_Off; }
      Depending on (Inverter_Fail) { Validate Pump_Inverter_Off; }
      > CO2 Exhaust Valve Closed
      > MINI Exhaust Valve Closed
   +1 > CO2 Scroll Pump Off
   +1 > MINI Scroll Pump Off
      Hold until ( PUMP_TEMP_OK(convert(CPmpT)+5) &&
           PUMP_TEMP_OK(convert(MPmpT)+5) );
      Validate Pump_Start;
}

State Pump_Inverter_Off {
      Depending on (Shutdown) { Validate Pump_Shutdown; }
      > CO2 Exhaust Valve Closed
      > MINI Exhaust Valve Closed
   +1 > CO2 Scroll Pump Off
   +1 > MINI Scroll Pump Off
      Hold until valid (Inverter_On);
      Validate Pump_Start;
}

State Pump_Shutdown {
   +1 > CO2 Exhaust Valve Closed
   +1 > MINI Exhaust Valve Closed
      # Wait until cell is filled to 1 Atm before shutting down
      # pumps since Exhaust valves do not hold against reverse
      # pressure
      Hold until valid (GasDeck_Is_Shutdown) or 2:00;
   +1 > CO2 Scroll Pump Off
   +1 > MINI Scroll Pump Off
   +1 Validate Pump_Off;
}

State Pump_Off {
    Hold until valid (Pump_Cool_Is_Shutdown);
    Validate Pump_Is_Shutdown;
}

State Pump_Is_Shutdown {}


# -----------------------------------------------------------------------------
# Partition 11: Pump Cooling Control
# -----------------------------------------------------------------------------
Partition

%{
  #define BATH_TEMP_COLD 20
  #define PUMP_TEMP_COLD 35
  #define BATH_TEMP_OK(x) (x > BATH_TEMP_COLD)
  #define PUMP_COLD_OK(x) (x < PUMP_TEMP_COLD)
%}

State Pump_Cool_Init {
    > Coolant Pump Off
    > Coolant Divert Off
    > Panel Top LED Off
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    Depending on (Record) { Validate Pump_Cool_Start; }
}

State Pump_Cool_Start {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    Depending on (Inverter_Off) { Validate Pump_Cool_Inverter_Off; }
    Depending on (Inverter_Fail) { Validate Pump_Cool_Inverter_Off; }
    Hold until valid (Inverter_On);
 +1 > Coolant Pump On
 +5 Validate Pump_Cool_Watch;
}

State Pump_Cool_Watch Nolog {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    Depending on (Inverter_Off) { Validate Pump_Cool_Inverter_Off; }
    Depending on (Inverter_Fail) { Validate Pump_Cool_Inverter_Off; }
    { if (convert(CoolP) < 25) Validate Pump_Cool_LowP; }
    { if (convert(CoolP) > 75) Validate Pump_Cool_HiP; }
 +1 > Coolant Divert Off
 +1 hold until ( !BATH_TEMP_OK(convert(WTnkT)) );
 +1 hold until ( BATH_TEMP_OK(convert(WTnkT))) or 5
    else Validate Pump_Cool_Cold;
    Validate Pump_Cool_Watch;
}

State Pump_Cool_Cold {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    Depending on (Inverter_Off) { Validate Pump_Cool_Inverter_Off; }
    Depending on (Inverter_Fail) { Validate Pump_Cool_Inverter_Off; }
    { if (convert(CoolP) < 25) Validate Pump_Cool_LowP; }
    { if (convert(CoolP) > 75) Validate Pump_Cool_HiP; }
    > Coolant Divert On
    Hold until (BATH_TEMP_OK(convert(WTnkT)-5));
 +1 > Coolant Divert Off
 +1 Validate Pump_Cool_Watch;
}

State Pump_Cool_Inverter_Off {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    > Coolant Pump Off
 +1 > Coolant Divert Off
    Hold until valid (Inverter_On);
 +5 Validate Pump_Cool_Start;
}

State Pump_Cool_LowP {
      Hold Until (convert(CoolP) >= 25) or 10
      else Validate Pump_Cool_Watch;
   +1 { msg( 2, "Low Coolant Pressure: %.1lf", convert(CoolP)); }
   +1 > Panel Top LED Red
      > Panel Display Text \\nLow Coolant Pressure
      > Coolant Pump Off
      # Remain off
    Depending on (Shutdown) { Validate Pump_Cool_Is_Shutdown; }
}

State Pump_Cool_HiP {
      > Coolant Divert On
      { msg( 2, "High Coolant Pressure: %.1lf", convert(CoolP)); }
   +1 Validate Pump_Cool_HiP_Watch;
}

State Pump_Cool_HiP_Watch {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    Depending on (Inverter_Off) { Validate Pump_Cool_Inverter_Off; }
    { if (convert(CoolP) < 25) Validate Pump_Cool_LowP; }
   +1 Hold until (convert(CoolP) < 75) or 10
      else Validate Pump_Cool_HiP_Fail;
      Hold until (convert(CoolP) > 75);
      Validate Pump_Cool_HiP_Watch;
}

State Pump_Cool_HiP_Fail {
    { msg( 2, "High Coolant Pressure Fail: %.1lf", convert(CoolP)); }
    > Coolant Pump Off
    Depending on (Shutdown) { Validate Pump_Cool_Is_Shutdown; }
}

State Pump_Cool_Shutdown {
   +1 Hold until valid (Pump_Off);
   +1 hold until ( PUMP_COLD_OK(convert(CPmpT)) &&
         PUMP_COLD_OK(convert(MPmpT)) );
   +1 > Coolant Pump Off
   +1 Validate Pump_Cool_Is_Shutdown;
}

State Pump_Cool_Is_Shutdown {}


# -----------------------------------------------------------------------------
# Partition 12: Luggage Bay Temperature Control
# Throttle Valve Control and Space Heater Control
# -----------------------------------------------------------------------------
Partition

%{
#define HEATER_HOT 2.0
#define HEATER_TEMP_OK(x) (x<HEATER_HOT)
#define BAY_HOT 25
#define BAY_TEMP_OK(x) (x<BAY_HOT)
%}

State LuggageBay_TCtrl_Init {
   +1 > HK Space Htr Ctl Off
    Depending on (Shutdown) { Validate LuggageBay_TCtrl_Shutdown; }
    Depending on (Record) { Validate LuggageBay_TCtrl_Start; }
    Hold until ((IOSwS & 3) == 3) ;
    Validate LuggageBay_TCtrl_Start; 
} 

State LuggageBay_TCtrl_Start {
    Depending on (Shutdown) { Validate LuggageBay_TCtrl_Shutdown; }
  +1 > HK Set Space Heater Temp Setpoint 1.90
  +1 > HK Space Htr Ctl On
     Validate LuggageBay_TCtrl_Watch;
} 

State LuggageBay_TCtrl_Watch Nolog {
    Depending on (Shutdown) { Validate LuggageBay_TCtrl_Shutdown; }
    Hold until (!HEATER_TEMP_OK(convert(SpHCT)) 
        || (!BAY_TEMP_OK( (convert(CRv5T)+convert(MRv5T))/2 )) );
    Hold until (HEATER_TEMP_OK(convert(SpHCT)) ) or 2
      else Validate LuggageBay_TCtrl_Hot;
 +1 > HK Set Space Heater Temp Setpoint 1.60
    Hold until (!HEATER_TEMP_OK(convert(SpHCT)) 
        || (BAY_TEMP_OK( (convert(CRv5T)+convert(MRv5T))/2 )) );
    Hold until (HEATER_TEMP_OK(convert(SpHCT)) ) or 2
      else Validate LuggageBay_TCtrl_Hot;
 +1 > HK Set Space Heater Temp Setpoint 1.90
 +1 Validate LuggageBay_TCtrl_Watch;
}

State LuggageBay_TCtrl_Hot {
    Depending on (Shutdown) { Validate LuggageBay_TCtrl_Shutdown; }
 +1 > HK Space Htr Ctl Off
    Hold until (convert(SpHCT) < 1.4);
 +1 > HK Space Htr Ctl On
     Validate LuggageBay_TCtrl_Watch;
} 

State LuggageBay_TCtrl_Shutdown {
     > HK Space Htr Ctl Off
} 

# State Throttle_Standby {
#   +5
#   depending on (OFF_GROUND) { Validate Throttle_init; }
#   depending on (IN_AIR) { Validate Throttle_init; }
# }
# 

#-------------------
# # INITIALIZE
# State Throttle_init     {
#        > drive Throttle Valve in 48000
#   +2   > drive Throttle Valve out 10000
#   +5   > drive Throttle Valve to 15000
#   +5   Validate Throttle_scan;
# }
# 
# # RUN & SCAN
# State Throttle_scan {
#         depending on (ON_GROUND) { Validate Throttle_shut; }
#         depending on (Shutdown) { Validate Throttle_shut; }
#         > drive Throttle Valve to 47000
#         Hold until (SW_St == SWS_TIMEWARP) or 34:00;
#         > drive Throttle Valve to 40000
#   +2:00 > drive Throttle Valve to 32500
#   +2:00 > drive Throttle Valve to 25000
#   +2:00 Validate Throttle_scan;
# }
# 
# State Throttle_shut {
#   > drive Throttle Valve in 48000
#   > drive Throttle Valve out 20
# }


# -----------------------------------------------------------------------------
# Partition 13: Mini Methane Temperature Control
# -----------------------------------------------------------------------------
Partition
%{
  #define TEMP_OK(x,y) ( y-x < 0.1 )
%}

State MTControl_Init {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
Depending on (Record) { Validate MTControl_Start; }
    Hold until ((IOSwS & 3) == 3) ;
    Validate MTControl_Start; 
}

State MTControl_Start {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
    +1 > MINI Set LPV External TEC Setpoint 1.30
    +1 > MINI Set DPV Temp Setpoint 1.39
    +1 > MINI Set Cell Temp Setpoint 1.39
    +1 > MINI Cell Htr Ctl On
   +10 > MINI DPV Htr Ctl On
   +10 > MINI LPV Ext TEC On
   +1  Validate MTControl_Watch;
}

State MTControl_Watch NoLog {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
    Hold until (!TEMP_OK(convert(MLPVCT),convert(MLPVTSt))
        || !TEMP_OK(convert(MDPVTSt),convert(MDPVCT))
        || !TEMP_OK(convert(MCelTSt),convert(MCelCT)) );

    Hold until (TEMP_OK(convert(MLPVCT),convert(MLPVTSt))
        && TEMP_OK(convert(MDPVTSt),convert(MDPVCT))
        && TEMP_OK(convert(MCelTSt),convert(MCelCT)) ) or 2
    else Validate MTControl_Not_OK;
    Validate MTControl_Watch;
}

State MTControl_Not_OK {
    Depending on (Shutdown) { Validate MTControl_Shutdown; }

    hold until ( TEMP_OK( convert(MLPVCT),convert(MLPVTSt) ) )
    or 1 else > MINI LPV Ext TEC Off

    hold until (TEMP_OK(convert(MDPVTSt),convert(MDPVCT)))
    or 1 else > MINI DPV Htr Ctl Off

    hold until (TEMP_OK(convert(MCelTSt),convert(MCelCT)))
    or 1 else > MINI Cell Htr Ctl Off

    +1 > Reprogram CB2 DACs
   +10 > MINI Cell Htr Ctl On
    +1 > MINI DPV Htr Ctl On
    +1 > MINI LPV Ext TEC On
 +1:00 Validate MTControl_Watch;
}

State MTControl_Shutdown {
    > MINI Cell Htr Ctl Off
    > MINI DPV Htr Ctl Off
    > MINI LPV Ext TEC Off
}

# -----------------------------------------------------------------------------
# Partition 14: CO2 Temperature Control
# -----------------------------------------------------------------------------
Partition

State CTControl_Init {
  Depending on (Shutdown) { Validate CTControl_Shutdown; }
  Depending on (Record) { Validate CTControl_Start; }
    Hold until ((IOSwS & 3) == 3) ;
    Validate CTControl_Start; 
}

State CTControl_Start {
Depending on (Shutdown) { Validate CTControl_Shutdown; }
    +1 > CO2 Set LPV Temp Setpoint 1.39
    +1 > CO2 Set Cell Temp Setpoint 1.39
    +1 > CO2 Cell Htr Ctl On
   +10 > CO2 LPV Htr Ctl On
   +1  Validate CTControl_Watch;
}

State CTControl_Watch NoLog {
  Depending on (Shutdown) { Validate CTControl_Shutdown; }
    Hold until (!TEMP_OK(convert(CLPVTSt),convert(CLPVCT)) ||
        !TEMP_OK(convert(CCelTSt),convert(CCelCT)) );
    Hold until (TEMP_OK(convert(CLPVTSt),convert(CLPVCT)) &&
        TEMP_OK(convert(CCelTSt),convert(CCelCT)) ) or 2
    else Validate CTControl_Not_OK;
    Validate CTControl_Watch;
}

State CTControl_Not_OK {
    Depending on (Shutdown) { Validate CTControl_Shutdown; }
    hold until (TEMP_OK(convert(CLPVTSt),convert(CLPVCT)))
    or 1 else > CO2 LPV Htr Ctl Off
    hold until (TEMP_OK(convert(CCelTSt),convert(CCelCT)))
    or 1 else > CO2 Cell Htr Ctl Off
    +1 > Reprogram CB2 DACs
   +10 > CO2 Cell Htr Ctl On
    +1 > CO2 LPV Htr Ctl On
    +1 Validate CTControl_Watch;
}

State CTControl_Shutdown {
    > CO2 Cell Htr Ctl Off
    > CO2 LPV Htr Ctl Off
}

# -----------------------------------------------------------------------------
# Partition 15: Realtime File Input
# -----------------------------------------------------------------------------
Partition
State ReadFile_idle {}

State ReadFile "HCI.tmas" {
  +5 Validate ReadFile_idle;
}


#---------------------------------------------------------------
# Partition 16: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------
Partition
State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SWStat == SWS_TIMEWARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}


#---------------------------------------------------------------
# Partition 17: Analog Input Monitoring
#---------------------------------------------------------------
Partition
%{
  AI_T30K Last_PC__T = 0;
  static int PC__T_static_count = 0;
  static int PC__T_delta_count = 0;
  static int AI_Reset_count = 0;
  static int AI_Reset_limit = 0;
%}
State AI_Watch {
    { if ( PC__T == Last_PC__T ) {
        if ( ++PC__T_static_count >= 5 ) {
          msg(2, "PC__T has not changed in 5 seconds");
          PC__T_delta_count = 0;
          Validate AI_Reset;
        }
      } else {
        Last_PC__T = PC__T;
        PC__T_static_count = 0;
        if ( ++PC__T_delta_count > 5 ) {
          PC__T_delta_count = 0;
          AI_Reset_count = 0;
        }
      }
    }
}

State AI_Reset {
      > AI Reset
  +1  > AI Double Convert Row Zero
      { if ( AI_Reset_limit > 0 &&
             ++AI_Reset_count >= AI_Reset_limit ) {
          msg(2,"AI Max Reset Count Reached");
          Validate AI_Fail;
        }
      }
      Hold until ( PC__T != Last_PC__T ) OR 5
      else Validate AI_Reset;
      Validate AI_Watch;
}

State AI_Fail {}

# -----------------------------------------------------------------------------
# Partition for MINI Laser TEC Ramping
# -----------------------------------------------------------------------------
Partition
%{
  double MLTE_crnt, MLTE_limit;
  #define MLTE_ramp_length .08
  #define MLTE_increment .001
%}

State MINI_Laser_TEC_Ramp_Idle {}

State MINI_Laser_TEC_Ramp {
  { MLTE_crnt = convert(MLTETSt);
    MLTE_limit = MLTE_crnt + MLTE_ramp_length;
  }
    > MINI Set Laser TEC Temp Setpoint 1.3
 +5 Validate MINI_Laser_TEC_Ramp_Loop;
}

State MINI_Laser_TEC_Ramp_Loop NoLog {
  { if (convert(MLTETSt) >= MLTE_limit) Validate MINI_Laser_TEC_Ramp_Idle;
    MLTE_crnt += MLTE_increment;
    ci_sendfcmd(2, "MINI Set Laser TEC Temp Setpoint %.3lf\n", MLTE_crnt);
  }
}


# -----------------------------------------------------------------------------
# Partition for CO2 Laser TEC Ramping
# -----------------------------------------------------------------------------
Partition
%{
  double CLTE_crnt, CLTE_limit;
  #define CLTE_ramp_length .05
  /* #define CLTE_increment .001875 */
  #define CLTE_increment .0006
%}

State CO2_Laser_TEC_Ramp_Idle {}

State CO2_Laser_TEC_Ramp {
  { CLTE_crnt = convert(CLTETSt);
    CLTE_limit = CLTE_crnt - CLTE_ramp_length;
  }
    > CO2 Set Laser TEC Temp Setpoint 1.4
#   > Panel Clear Screen
#   > Panel Display Text Wait for settle\n
# +3 Hold Until (convert(CLTE4R3T) - convert(CLTETSt) > 0 &&
#                convert(CLTE4R3T) - convert(CLTETSt) < 0.07) or 3:00;
#   > Panel Display Text Ramping\n
    Validate CO2_Laser_TEC_Ramp_Loop;
}

State CO2_Laser_TEC_Ramp_Loop NoLog {
  { if (convert(CLTETSt) <= CLTE_limit) Validate CO2_Laser_TEC_Ramp_Done;
    CLTE_crnt -= CLTE_increment;
    ci_sendfcmd(2, "CO2 Set Laser TEC Temp Setpoint %.3lf\n", CLTE_crnt);
  }
}

State CO2_Laser_TEC_Ramp_Done NoLog {
#  > Panel Clear Screen
#  > Panel Display Text CO2 Laser TEC Ramp\nCompleted\n
  Validate CO2_Laser_TEC_Ramp_Idle;
}

# -----------------------------------------------------------------------------
# Partition for BAT Purge
# -----------------------------------------------------------------------------
Partition

State BAT_Purge_Watch {
  Hold until (PP_BAT_Purge_LED);
  Hold until (!PP_BAT_Purge_Req) or 2
  else Validate BAT_Purge_Cancel;
  > BAT Purge On
  Hold until (PP_BAT_Purge_Req || (SWStat == SWS_TIMEWARP)) or 2:00;
  > BAT Purge Off
  Hold until (!PP_BAT_Purge_Req);
  > Panel Purge LED Off
  Hold until (!PP_BAT_Purge_LED);
  Validate BAT_Purge_Watch;
}

State BAT_Purge_Cancel {
  > BAT Purge Off
  Hold until (!PP_BAT_Purge_Req);
  > Panel Purge LED Off
  Hold until (!PP_BAT_Purge_LED);
  Validate BAT_Purge_Watch;
}

#----------------------------------------------------------------
# Partition for Inverter
#----------------------------------------------------------------
Partition

State Inverter_Init {
     depending on (Shutdown) { Validate Inverter_Shutdown; }
  +3 > Inverter Arm On
     Hold until (InvPwrS == 1 && InvErrS == 0) or 5
     else Validate Inverter_Off;
     Validate Inverter_On;
}

State Inverter_On {
    depending on (Shutdown) { Validate Inverter_Shutdown; }
    { if (!Pump_Ground_Power &&
          (!InvPwrS || InvErrS ||
           (convert(PM1V1) < 26.5 && convert(PM1I1) < 1)))
        Validate Inverter_Off;
    }
    { if (!Pump_Ground_Power && !InverterArm_S) {
        msg(2, "!InverterArm_S implies Power Bus 1 Off");
        Validate Inverter_Fail;
      }
    }
}

State Inverter_Off {
    depending on (Shutdown) { Validate Inverter_Shutdown; }
    depending on (1 Hz) { if (Pump_Ground_Power) Validate Inverter_On; }
    > Inverter Power Off
 +2 Hold until (convert(PM1V1) > 27);
    > Inverter Power On
    Hold until (InvPwrS == 1 && !InvErrS) or 5
    else Validate Inverter_Off;
    Validate Inverter_On;
}

State Inverter_Shutdown {
      Hold until valid (Pump_Is_Shutdown);
   +1 > Inverter Power Off
   +1 > Inverter Arm Off
      Validate Inverter_Is_Shutdown;
}

State Inverter_Is_Shutdown {}

State Inverter_Fail {
      > Panel Display Text \\nBus 1 Power Failure
      > Inverter Power Off
      > Inverter Arm Off
}

# -----------------------------------------------------------------------------
# Partition GPS/INS/BAT 
# -----------------------------------------------------------------------------
Partition

State BAT_SPAN_Init {
  Hold Until (SWStat == SWS_TIMEWARP) or 5:00;
  Hold Until (PP_Land_LED || SWS_TIMEWARP) or 10:00;
  Validate BAT_SPAN_Watch;
}

State BAT_SPAN_Watch {
  Hold Until (((IOSwS & 3) == 3) &&
              ((BSstale > 5) || (INS_status != 3) ||
                (n_bat_records < 45) || (n_span_records < 45)));
  Hold Until (!(((IOSwS & 3) == 3) &&
               ((BSstale > 5) || (INS_status != 3) ||
                (n_bat_records < 45) || (n_span_records < 45)))) or 30
  else Validate BAT_SPAN_Fail;
  Validate BAT_SPAN_Watch;
}

State BAT_SPAN_Fail {
  > Panel Display Text \\nBAT/GPS Failure
}
