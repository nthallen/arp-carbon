# =============================================================================
# Centaur Flights, 2012/2013; Manassas, VA, Test Flights.
# Flight HTW.tma.
# =============================================================================


# -----------------------------------------------------------------------------
# Partition 1: Main Line Code
# -----------------------------------------------------------------------------

### Need to verify switches before we use them
# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised), most algo processing is suspended.
# If both switches are On (1, raised) Shutdown begins immediately.

# { tma_hold( ( (IOSwS & 3) == 1) || ( (IOSwS & 3) == 2) ); }
#{ depending on (Shutdown) {} 
#   else {
#      if ( (IOSwS & 3) == 3)
#          Validate Shutdown;
#   }
#}

%{
  #include "msg.h"
  #include "swstat.h"
%}

# INITIALIZE
State Init {
       > Telemetry Start
  +1   > Fail Light Off
  +2   Validate Standby;
}

# WAIT 
State Standby {
        depending on (TAKE_DATA) { Validate Record; }
        depending on (LAND)      { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
}

# RECORD  
State Record {
        depending on (LAND)      { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
        "In Record";
}

# SHUTDOWN
State Shutdown {
      Hold until valid (HCI_Is_Shutdown) or 20;
 +5   > Fail Light On
      > quit
}

# -----------------------------------------------------------------------------
# Partition 3: Flight Mode
# -----------------------------------------------------------------------------

Partition

# This partition looks for pilot panel switch position and flight sensors to decide state of instrument. 
# IN Flight, Take Data, Land, Calibrate. 
# (ON_GROUND, OFF_GROUND, IN_AIR). \

%{ /* Altitude definitions */
    double P_ground_up = 525.;
    double P_ground_dn = 575.;
    double P_clouds_up = 280.;
    double P_clouds_dn = 370.;
    int using_swp = 0;
%}

State In_FLIGHT {
  { using_swp = 0; }
  { if (using_swp || (DACS_P > 0 && DACS_P < P_ground_up))
      Validate TAKE_DATA;
  }
}

State TAKE_DATA {
  { if ((using_swp == 2) || (!using_swp && DACS_P > 0 && DACS_P < P_clouds_up)) {
      Validate LAND;
    }
  }
}

State LAND {
  { if ( (using_swp == 3) || (!using_swp && DACS_P > P_clouds_dn))
      Validate IN_FLIGHT;
  }
}




#----------------------------------------------------------------
# Partition 4: HCI Main Control
#----------------------------------------------------------------
Partition
State HCI_Init {
     Depending on (Shutdown) { Validate HCI_Shutdown; }
     Depending on (Record) { Validate HCI_Startup; }
}

State HCI_Startup {
      Depending on (Shutdown) { Validate HCI_Shutdown; }
   +5 > HK Set Sample Heater Temp Setpoint 1.25
   +1 > Sample Htr Ctl On
}

State HCI_Shutdown {
      > Sample Htr Ctl Off
      Hold until valid (MINI_Is_Shutdown) or 20;
      Hold until valid (CO2_Is_Shutdown) or 20;
      Hold until valid (Pump_TControl_Is_Shutdown) or 10;
   +5 Validate HCI_Is_Shutdown;
}

State HCI_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 5: Mini Methane Control
#----------------------------------------------------------------
Partition

%{
  int MINI_Ready_To_Calibrate
}%
State MINI_Init {
   +1 > MINI Pressure Reg Closed
   +1 > MINI Exhaust Valve Closed
      Depending on (Shutdown) { Validate MINI_Shutdown; }
      Depending on (Record) { Validate MINI_Start; }
}

State MINI_Start {
      Depending on (Shutdown) { Validate MINI_Shutdown; }
   +1 Validate MTControl_Start;
   +5 Validate MQCL_SelectWaveandRun;
   +5 Hold until valid (MQCL_Watch);
   +1 Validate MINI_Sample;
}

State MINI_Sample {
     Depending on (Shutdown) { Validate MINI_Shutdown; }
     > MINI Set Cell Pressure Setpoint 40
     Hold until (convert(MCelLP) < 40)
  +1 > MINI Pressure Reg Open
+30:00 Validate MINI_Calibrate;
}

State MINI_Calibrate {
     Depending on (Shutdown) { Validate MINI_Shutdown; }
     { MINI_Ready_To_Calibrate = 1; }
     {Depending on (1Hz) { if ( MINI_Ready_To_Calibrate == 0 ) Validate MINI_Sample; } }
}

State MINI_Shutdown {
     > MINI Pressure Reg Closed
  +1 > MINI Exhaust Valve Closed
  +1 > MINI Scroll Pump Off
  +1 Hold until valid (MQCL_Is_Shutdown)
     Validate MINI_Is_Shutdown;
}

State MINI_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 6: CO2 Control
#----------------------------------------------------------------
Partition

#----------------------------------------------------------------
# Partition 7: Mini Methane Laser Control 7.7um QCL ICOS
#----------------------------------------------------------------
Partition
%{
 int num_MQCL_recovers=0;
 #define LOW_CURRENT 0.02
 #define MQCL_TEMP_LIMIT 1.3
 #define MQCL_TEMP_OK(x,y) (x > MQCL_TEMP_LIMIT && fabs(x - y) < 0.2)
%}
# Mini Starting and Stopping

State MQCL_Init {
  +1  > SSP_M Stop
  +1  > QCLI_M Stop
      Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
      else > QCLI_M clear errors
      Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
      else Validate MQCL_Stop_Reset;
      Validate MQCL_Idle;
}

State MQCL_Idle {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
}

State MQCL_Start {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    Hold until ( SSP_M_Status == SSP_M_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP_M Not Ready in MQCL_Start" );
      Validate MQCL_SSP_M_Recover;
    }
    Hold until ( MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ) or 10
    else Validate MQCL_Out_TSpec;
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 5
    else Validate MQCL_QCLI_M_Recover;
 +1 > SSP_M Start
    Hold until ( SSP_M_Status == SSP_M_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in MQCL_Start" );
      Validate MQCL_SSP_M_Recover;
    }
    > QCLI_M Run
    Hold until ( SSP_M_Status == SSP_M_STATUS_TRIG && convert(MLasI) > LOW_CURRENT ) or 20
    #Hold until ( SSP_M_Status == SSP_M_STATUS_TRIG ) or 20
    else Validate MQCL_SSP_M_Recover;
    { num_MQCL_recovers = 0; }
    Validate MQCL_Watch;
}

State MQCL_Watch NoLog {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    { if ( SSP_M_Status == SSP_M_STATUS_READY ) {
        nl_error( 2, "SSP_M Went Ready Spontaneously" );
        Validate MQCL_SSP_M_Recover;
      }
    }
         # convert(HNano_I) < LOW_CURRENT ||
    hold until ( SSP_M_Status != SSP_M_STATUS_TRIG ||
         !MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ||
	 convert(MLasI) <= LOW_CURRENT));
    hold until ( SSP_M_Status == SSP_M_STATUS_TRIG &&
         MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) &&
	 convert(MLasI) >= LOW_CURRENT)) or 2
    else Validate MQCL_Watch;
%{  
    if (!MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) Validate MQCL_Out_TSpec;
    if (convert(MLasI) <= LOW_CURRENT) Validate MQCL_Out_Spec;
    if (SSP_M_Status != SSP_M_STATUS_TRIG) Validate MQCL_SSP_M_Recover;
}%
    Validate MQCL_Watch;
}

State MQCL_SSP_M_Recover NoLog {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    { if ( ++num_MQCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_MQCL_recovers. Trying reset" );
        num_MQCL_recovers = 0;
        Validate MQCL_QCLI_M_Reset;
      }
    }
    Hold until ( SSP_M_Status == SSP_M_STATUS_READY ) or 10
    else Validate MQCL_SSP_M_Not_Talking;
 +2 > QCLI_M Stop
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCL_QCLI_M_Reset;
    Validate MQCL_Start;
}

State MQCL_SSP_M_Not_Talking {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    { if ( ++num_MQCL_recovers > 20 ) Validate MQCL_Fail; }
    Hold until ( SSP_M_Status == SSP_M_STATUS_READY ) or 10
    else Validate MQCL_SSP_M_Not_Talking;
    Validate MQCL_SSP_M_Recover;
}

State MQCL_Fail {
    > Log Laser MQCL Has Failed
 +1 Validate MQCL_Shutdown;
}

State MQCL_Shutdown {
    > SSP_M Stop
 +1 > QCLI_M Stop
    Hold until ( !(QCLI_M_s & 0x1000) ) or 2
    else Validate MQCL_Shutdown_Reset;
    > Log Laser MQCL Has Shutdown
    > MINI Laser TEC Off
    Validate MQCL_Is_Shutdown;
}

State MQCL_Shutdown_Reset {
    > Command QCLI_M_Reset On
 +1 > Command QCLI_M_Reset Off
    Validate MQCL_Shutdown;
}

State MQCL_Is_Shutdown {}

State MQCL_Out_Spec {
    > QCLI_M Stop
 +1 Validate MQCL_QCLI_M_Recover;
}

State MQCL_Out_TSpec {
    > QCLI_M Stop
 +1 > MINI Laser TEC Off
 +5 > MINI Laser TEC On
    Hold until ( MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ) or 10
    else Validate MQCL_Out_TSpec;
 +1 Validate MQCL_Start;
}

State MQCL_QCLI_M_Recover {
   Depending on (Shutdown) { Validate MQCL_Shutdown; }

 +1  { nl_error( 2, "QCLI_M reporting error status 0x%04X", QCLI_M_s ); }
 +1  > QCLI_M Clear Errors
     Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 5
     else {
       nl_error( 2, "QCLI_M error did not clear: Resetting" );
       Validate MQCL_QCLI_M_Reset;
     }
     Validate MQCL_Start;
}

State MQCL_QCLI_M_Reset {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    { if ( ++num_MQCL_recovers > 20 ) {
        nl_error( 2,"Exceeded num_MQCL_recovers in QCLI_M_Reset: Invoking shutdown" );
        Validate MQCL_Fail;
      }
    }
 +1 > Command QCLI_M_Reset On
    > Command QCLI_M_Reset Off
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCL_QCLI_M_Reset;
    { ci_sendfcmd( 0, "Select QCLI_M Waveform Number %d\n", QCLI_M_Wave );
      Validate MQCL_Start;
    }
}

State MQCL_Stop {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
 +1 > QCLI_M Stop
    Hold until ( !(QCLI_M_s & 0x1000)) or 2
    else Validate MQCL_Stop_Reset;
    Hold until ( SSP_M_Status == SSP_M_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in MQCL_Stop" ); }
    Validate MQCL_Idle;
}

State MQCL_Stop_Reset {
    > Command QCLI_M_Reset On
 +1 > Command QCLI_M_Reset Off
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCL_Stop_Reset;
    { ci_sendfcmd( 0, "Select QCLI_M Waveform Number %d\n", QCLI_M_Wave );
      Validate MQCL_Idle;
    }
}

#Running Waveforms

State MQCL_SelectWaveandRun {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    Hold until ( SSP_M_Status == SSP_M_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in M2Cd_800Hz" ); }
    > QCLI_M Stop
    Hold until ( !(QCLI_M_s & 0x1000) ) or 2
    else Validate MQCL_SelectWaveandRun_Reset;
 +1 > MINI Set Laser TEC Temp Setpoint 1.4
 +1 > MINI Laser TEC On
 +5 > Select QCLI_M Waveform M2Cd_800Hz
 +2 Validate MQCL_Start;
}

State MQCL_SelectWaveandRun_Reset {
    > Command QCLI_M_Reset On
 +1 > Command QCLI_M_Reset Off
    Hold until ( !(QCLI_M_s & 0x1000) ) or 2
    else Validate MQCL_SelectWaveandRun_Reset;
    Validate MQCL_SelectWaveandRun;
}

#----------------------------------------------------------------
# Partition 6: CO2 Laser Control 4.3um QCL ICOS
#----------------------------------------------------------------
Partition


#----------------------------------------------------------------
# Partition 6: Calibration Logic 
#----------------------------------------------------------------
Partition

State Calibrate_Logic {
    { Depending on (1Hz) { if ( MINI_Ready_To_Calibrate == 1 ) Validate Calibrate_MINI; 
    else if ( CO2_Ready_To_Calibrate == 1 ) Validate Calibrate_CO2; }
    }
}

State Calibrate_MINI {
{ Cell_Ctrl = 0; }  
   +1 > MINI Pressure Reg Closed 
   +1 > MINI Gas Valve Open
   +1 Validate GasDeck_PI_Init;
+2:00 Validate GasDeck_Close;
      { MINI_Ready_To_Calibrate == 0 }
   +1 Validate Calibrate_Logic
}

State Calibrate_CO2 {
{ Cell_Ctrl = 1; }
   +1 > CO2 Pressure Reg Closed 
   +1 > CO2 Gas Valve Open
   +1 Validate GasDeck_PI_Init;
+2:00 Validate GasDeck_Close;
      { CO2_Ready_To_Calibrate == 0 }
   +1 Validate Calibrate_Logic
}


#----------------------------------------------------------------
# Partition 7: Gas Deck Pressure Control
#----------------------------------------------------------------
Partition

%{
  double P_sum = 0.;
  int Cell_Ctrl;
  #define US_CAST(x) ((unsigned short)(x))
  #define MAX_CAL_BITS 2047
  #include <math.h> /* for fabs */
%}

State GasDeck_Init {
     > Gas Deck Flow Controller Closed
     > Gas Deck Valve Closed
     > MINI Gas Valve Closed
     > CO2 Gas Valve Closed
 +1  Validate GasDeck_Idle;
}

State GasDeck_Idle {
}

State GasDeck_PI_Init {
  { P_sum = 0; Gp = 1; Gi = 0.5; }
     > GASDECK Set Gas Flow Setpoint 0
     > Gas Deck Flow Controller On
  +1 > Gas Deck Valve Open
  +2 > Validate GasDeck_PI;
}

State GasDeck_PI {
  { double P, Gp, Gi, P_set, P_diff, dstep;
    unsigned short ustep;
    P = Cell_Ctrl ? convert(CCelP):convert(MCelP);
    P_set = Cell_Ctrl ? convert(CCelPSt):convert(MCelPSt);
    P_diff = P_set - P;
    P_sum += P_diff * Gi;
    if ( P_sum > MAX_CAL_BITS )
      P_sum = MAX_CAL_BITS;
    else if ( P_sum < 0 ) P_sum = 0;
    dstep = P_diff * Gp + P_sum;
    if (dstep<0) dstep = 0;
    else if (dstep > MAX_CAL_BITS) dstep = MAX_CAL_BITS;
    ustep = US_CAST(dstep);
    ci_sendfcmd(2, "GASDECK Set Gas Flow Setpoint %u\n", ustep);
  }
}

#State GasDeck_Fill_Cell {
#  +1 > Bench Flow 1 Setpoint 400
#  Hold Until ( convert(HCInP) > convert(PV_SetP)-10 ) or 5:00;
#     > Bench Flow 1 Setpoint 100
#  Hold Until ( convert(HCInP) > convert(PV_SetP)-2 ) or 5:00;
#     > Bench Flow 1 Setpoint 50
#  Hold Until ( convert(HCInP) > convert(PV_SetP)-0.2 ) or 5:00;
#     > Bench Flow 1 Setpoint 0
#  Validate Bench_Idle;
#}

State GasDeck_Close {
     > Gas Deck Flow Controller Closed
     > Gas Deck Valve Closed
     > MINI Gas Valve Closed
     > CO2 Gas Valve Closed
  +1 Validate GasDeck_Idle;
}

State 
#----------------------------------------------------------------
# Partition 8: Pump Cooling Control
#----------------------------------------------------------------
Partition

State Pump_Init {
}

# -----------------------------------------------------------------------------
# Partition 9: Luggage Bay Temperature Control
# Throttle Valve Control and Space Heater Control
# -----------------------------------------------------------------------------
# 
# Partition
# 
# State Throttle_Standby {
#   +5
#   depending on (OFF_GROUND) { Validate Throttle_init; }
#   depending on (IN_AIR) { Validate Throttle_init; }
# }
# 
# Space heater control should get moved with throttle to luggage bay heater control
#  +10 > HK Set Space Heater Temp Setpoint 1.25
#   +1 > Space Heater Controller On
#-------------------
# # INITIALIZE
# State Throttle_init     {
#        > drive Throttle Valve in 48000
#   +2   > drive Throttle Valve out 10000
#   +5   > drive Throttle Valve to 15000
#   +5   Validate Throttle_scan;
# }
# 
# # RUN & SCAN
# State Throttle_scan {
#         depending on (ON_GROUND) { Validate Throttle_shut; }
#         depending on (Shutdown) { Validate Throttle_shut; }
#         > drive Throttle Valve to 47000
#         Hold until (SW_St == SWS_TIMEWARP) or 34:00;
#         > drive Throttle Valve to 40000
#   +2:00 > drive Throttle Valve to 32500
#   +2:00 > drive Throttle Valve to 25000
#   +2:00 Validate Throttle_scan;
# }
# 
# State Throttle_shut {
#   > drive Throttle Valve in 48000
#   > drive Throttle Valve out 20
# }

# -----------------------------------------------------------------------------
# Partition 10: Mini Methane Temperature Control
# -----------------------------------------------------------------------------
Partition
%
#define TEMP_OK(x,y) ( y-x < 0.5 )
%

State MTControl_Init {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
}

State MTControl_Start {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
    +1 > MINI Set LPV External TEC Setpoint 1.25
    +1 > MINI Set DPV Temp Setpoint 1.25
    +1 > MINI Set Cell Temp Setpoint 1.25
    +1 > MINI Cell Htr Ctl On
   +10 > MINI Detector PV Htr Ctl On
   +10 > MINI LPV TEC On
   +1  Validate MTControl_Watch;
}

State MTControl_Watch NoLog {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
    Hold until (!TEMP_OK(convert(MLPVTSt),convert(MLPVCT)) || !TEMP_OK(convert(MDPVTSt),convert(MDPVCT))
                   || !TEMP_OK(convert(MCelTSt),convert(MCelCT)) );
    Hold until (TEMP_OK(convert(MLPVTSt),convert(MLPVCT)) && TEMP_OK(convert(MDPVTSt),convert(MDPVCT))
                   && TEMP_OK(convert(MCelTSt),convert(MCelCT)) ) or 2
    else Validate MTControl_Not_OK;
    Validate MTControl_Watch;
}

State MTControl_Not_OK {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
       { if (!TEMP_OK(convert(MLPVTSt),convert(MLPVCT))) > MINI LPV TEC Off;} 
       { if (!TEMP_OK(convert(MDPVTSt),convert(MDPVCT))) > MINI Detector PV Htr Ctl Off;}
       { if (!TEMP_OK(convert(MCelTSt),convert(MCelCT))) > MINI Cell Htr Ctl Off;}
   +10 > MINI Cell Htr Ctl On
    +1 > MINI Detector PV Htr Ctl On
    +1 > MINI LPV TEC On
    +1 Validate MTControl_Watch;
}

State MTControl_Shutdown {
    > MINI Cell Htr Ctl Off
    > MINI Detector PV Htr Ctl Off
    > MINI LPV TEC Off
}

# -----------------------------------------------------------------------------
# Partition 11: CO2 Temperature Control
# -----------------------------------------------------------------------------
Partition

# -----------------------------------------------------------------------------
# Partition 12: Realtime File Input
# -----------------------------------------------------------------------------
Partition
State ReadFile_idle {}

State ReadFile "HTW.tmas" {
  +5 Validate ReadFile_idle;
}


#---------------------------------------------------------------
# Partition 13: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------
Partition
State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SW_St == SWS_TIMEWARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}


#---------------------------------------------------------------
# Partition 14: Analog Input Monitoring
#---------------------------------------------------------------
Partition
%{
  AI_T30K Last_PC__T = 0;
  static int PC__T_static_count = 0;
  static int PC__T_delta_count = 0;
  static int AI_Reset_count = 0;
  static int AI_Reset_limit = 0;
%}
State AI_Watch {
    { if ( PC__T == Last_PC__T ) {
	if ( ++PC__T_static_count >= 5 ) {
	  msg(2, "PC__T has not changed in 5 seconds");
	  PC__T_delta_count = 0;
	  Validate AI_Reset;
	}
      } else {
	Last_PC__T = PC__T;
	PC__T_static_count = 0;
	if ( ++PC__T_delta_count > 5 ) {
	  PC__T_delta_count = 0;
	  AI_Reset_count = 0;
	}
      }
    }
}

State AI_Reset {
      > AI Reset
  +1  > AI Double Convert Row Zero
      { if ( AI_Reset_limit > 0 &&
	     ++AI_Reset_count >= AI_Reset_limit ) {
	  msg(2,"AI Max Reset Count Reached");
	  Validate AI_Fail;
	}
      }
      Hold until ( PC__T != Last_PC__T ) OR 5
      else Validate AI_Reset;
      Validate AI_Watch;
}

State AI_Fail {}
