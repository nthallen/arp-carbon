# =============================================================================
# Centaur Flights, 2012/2013; Manassas, VA, Test Flights.
# Flight HTW.tma.
# =============================================================================


# -----------------------------------------------------------------------------
# Partition 1: Main Line Code
# -----------------------------------------------------------------------------

### Need to verify switches before we use them
# Switches - 1100: Algo., 1111: No Algo. (Use runfile.1100 for flight)
# For Flight, 2 Switches in the Off (Zero) Position.
# If either switch in On (1, raised), most algo processing is suspended.
# If both switches are On (1, raised) Shutdown begins immediately.

# { tma_hold( ( (IOSwS & 3) == 1) || ( (IOSwS & 3) == 2) ); }
#{ depending on (Shutdown) {} 
#   else {
#      if ( (IOSwS & 3) == 3)
#          Validate Shutdown;
#   }
#}

%{
  #include "msg.h"
%}

# INITIALIZE
State Init {
       > Telemetry Start
#  +1   > Fail Light Off
  +2   Validate Standby;
}

# WAIT 
State Standby {
        depending on (TAKE_DATA) { Validate Record; }
        depending on (LAND)      { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
}

# RECORD  
State Record {
        depending on (LAND)      { Validate Shutdown; }
        depending on (AI_Fail)   { Validate Shutdown; }
        "In Record";
}

# SHUTDOWN
State Shutdown {
      Hold until valid (HCI_Is_Shutdown);
# +5   > Fail Light On
      > quit
}

# -----------------------------------------------------------------------------
# Partition 2: Flight Mode
# -----------------------------------------------------------------------------

Partition

# This partition looks for pilot panel switch position and flight sensors to decide state of instrument. 
# IN Flight, Take Data, Land, Calibrate. 
# (ON_GROUND, OFF_GROUND, IN_AIR). \

%{ /* Altitude definitions */
    double P_ground_up = 525.;
    double P_ground_dn = 575.;
    double P_clouds_up = 280.;
    double P_clouds_dn = 370.;
    int using_swp = 0;
%}

State In_FLIGHT {
  { using_swp = 0; }
  { if (using_swp)
      Validate TAKE_DATA;
  }
}

State TAKE_DATA {
  { if (using_swp == 2)
      Validate LAND;
  }
}

State LAND {
  { if (using_swp == 3) 
      Validate IN_FLIGHT;
  }
}




#----------------------------------------------------------------
# Partition 3: HCI Main Control
#----------------------------------------------------------------
Partition
State HCI_Init {
     Depending on (Shutdown) { Validate HCI_Shutdown; }
     Depending on (Record) { Validate HCI_Start; }
}

State HCI_Start {
      Depending on (Shutdown) { Validate HCI_Shutdown; }
   +5 > HK Set Sample Heater Temp Setpoint 1.25
   +1 > Sample Htr Ctl On
}

State HCI_Shutdown {
      > Sample Htr Ctl Off
      Hold until valid (MINI_Is_Shutdown) or 20;
      Hold until valid (CO2_Is_Shutdown) or 20;
      Hold until valid (Pump_Cool_Is_Shutdown) or 5:00;
   +5 Validate HCI_Is_Shutdown;
}

State HCI_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 4: Mini Methane Control
#----------------------------------------------------------------
Partition

%{
  int MINI_Ready_To_Calibrate;
%}

State MINI_Init {
   +1 > MINI Pressure Reg Off
      Depending on (Shutdown) { Validate MINI_Shutdown; }
      Depending on (Record) { Validate MINI_Start; }
}

State MINI_Start {
      Depending on (Shutdown) { Validate MINI_Shutdown; }
   +1 Validate MTControl_Start;
   +5 Validate MQCL_SelectWaveandRun;
   +5 Hold until valid (MQCL_Watch);
   +1 Hold until valid (Pump_Watch);
   +1 Validate MINI_Sample;
}

State MINI_Sample {
     Depending on (Shutdown) { Validate MINI_Shutdown; }
     > MINI Set Cell Pressure Setpoint 40
     Hold until (convert(MCelLP) < 40);
  +1 > MINI Pressure Reg On
+30:00 Validate MINI_Calibrate;
}

State MINI_Calibrate {
     Depending on (Shutdown) { Validate MINI_Shutdown; }
     { MINI_Ready_To_Calibrate = 1; }
     Depending on (1Hz) {
       if ( MINI_Ready_To_Calibrate == 0 )
         Validate MINI_Sample;
     }
}

State MINI_Shutdown {
     > MINI Pressure Reg Off
  +1 Hold until valid (MQCL_Is_Shutdown);
     Validate MINI_Is_Shutdown;
}

State MINI_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 5: CO2 Control
#----------------------------------------------------------------
Partition

%{
  int CO2_Ready_To_Calibrate;
%}
State CO2_Init {
   +1 > CO2 Pressure Reg Off
      Depending on (Shutdown) { Validate CO2_Shutdown; }
      Depending on (Record) { Validate CO2_Start; }
}

State CO2_Start {
      Depending on (Shutdown) { Validate CO2_Shutdown; }
   +1 Validate CTControl_Start;
   +5 Validate CQCL_SelectWaveandRun;
   +5 Hold until valid (CQCL_Watch);
   +1 Hold until valid (Pump_Watch);
   +1 Validate CO2_Sample;
}

State CO2_Sample {
     Depending on (Shutdown) { Validate CO2_Shutdown; }
     > CO2 Set Cell Pressure Setpoint 40
     Hold until (convert(CCelLP) < 40);
  +1 > CO2 Pressure Reg On
+30:00 Validate CO2_Calibrate;
}

State CO2_Calibrate {
    Depending on (Shutdown) { Validate CO2_Shutdown; }
    { CO2_Ready_To_Calibrate = 1; }
    Depending on (1Hz) {
      if ( CO2_Ready_To_Calibrate == 0 )
        Validate CO2_Sample;
    }
}

State CO2_Shutdown {
     > CO2 Pressure Reg Off
  +1 Hold until valid (CQCL_Is_Shutdown);
     Validate CO2_Is_Shutdown;
}

State CO2_Is_Shutdown {}

#----------------------------------------------------------------
# Partition 6: Mini Methane Laser Control 7.7um QCL ICOS
#----------------------------------------------------------------
Partition
%{
 int num_MQCL_recovers=0;
 #define M_LOW_CURRENT 0.02
 #define MQCL_TEMP_LIMIT 1.3
 #define MQCL_TEMP_OK(x,y) (x > MQCL_TEMP_LIMIT && fabs(x - y) < 0.2)
%}
# Mini Starting and Stopping

State MQCL_Init {
  +1  > SSP_M Stop
  +1  > QCLI_M Stop
      Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
      else > QCLI_M clear errors
      Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
      else Validate MQCL_Stop_Reset;
      Validate MQCL_Idle;
}

State MQCL_Idle {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
}

State MQCL_Start {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    Hold until ( SSP_M_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP_M Not Ready in MQCL_Start" );
      Validate MQCL_SSP_M_Recover;
    }
    Hold until ( MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ) or 10
    else Validate MQCL_Out_TSpec;
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 5
    else Validate MQCL_QCLI_M_Recover;
 +1 > SSP_M Start
    Hold until ( SSP_M_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in MQCL_Start" );
      Validate MQCL_SSP_M_Recover;
    }
    > QCLI_M Run
    Hold until ( SSP_M_Status == SSP_STATUS_TRIG && convert(MLasI) > M_LOW_CURRENT ) or 20
    #Hold until ( SSP_M_Status == SSP_STATUS_TRIG ) or 20
    else Validate MQCL_SSP_M_Recover;
    { num_MQCL_recovers = 0; }
    Validate MQCL_Watch;
}

State MQCL_Watch NoLog {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    { if ( SSP_M_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP_M Went Ready Spontaneously" );
        Validate MQCL_SSP_M_Recover;
      }
    }
         # convert(HNano_I) < M_LOW_CURRENT ||
    hold until ( SSP_M_Status != SSP_STATUS_TRIG ||
         !MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ||
	 convert(MLasI) <= M_LOW_CURRENT );
    hold until ( SSP_M_Status == SSP_STATUS_TRIG &&
         MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) &&
	 convert(MLasI) >= M_LOW_CURRENT) or 2
    else Validate MQCL_Watch_Recover;
    Validate MQCL_Watch;
}

State MQCL_Watch_Recover {  
  { if (!MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)))
      Validate MQCL_Out_TSpec;
    else if (convert(MLasI) <= M_LOW_CURRENT)
      Validate MQCL_Out_Spec;
    else if (SSP_M_Status != SSP_STATUS_TRIG)
      Validate MQCL_SSP_M_Recover;
    else Validate MQCL_Watch;
  }
}

State MQCL_SSP_M_Recover NoLog {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    { if ( ++num_MQCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_MQCL_recovers. Trying reset" );
        num_MQCL_recovers = 0;
        Validate MQCL_QCLI_M_Reset;
      }
    }
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 10
    else Validate MQCL_SSP_M_Not_Talking;
 +2 > QCLI_M Stop
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCL_QCLI_M_Reset;
    Validate MQCL_Start;
}

State MQCL_SSP_M_Not_Talking {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    { if ( ++num_MQCL_recovers > 20 ) Validate MQCL_Fail; }
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 10
    else Validate MQCL_SSP_M_Not_Talking;
    Validate MQCL_SSP_M_Recover;
}

State MQCL_Fail {
    > Log Laser MQCL Has Failed
 +1 Validate MQCL_Shutdown;
}

State MQCL_Shutdown {
    > SSP_M Stop
 +1 > QCLI_M Stop
    Hold until ( !(QCLI_M_s & 0x1000) ) or 2
    else Validate MQCL_Shutdown_Reset;
    > Log Laser MQCL Has Shutdown
    > MINI Laser TEC Off
    Validate MQCL_Is_Shutdown;
}

State MQCL_Shutdown_Reset {
    > MINI QCLI Reset On
 +1 > MINI QCLI Reset Off
    Validate MQCL_Shutdown;
}

State MQCL_Is_Shutdown {}

State MQCL_Out_Spec {
    > QCLI_M Stop
 +1 Validate MQCL_QCLI_M_Recover;
}

State MQCL_Out_TSpec {
    > QCLI_M Stop
 +1 > MINI Laser TEC Off
 +5 > MINI Laser TEC On
    Hold until ( MQCL_TEMP_OK(convert(MLTE7R7T),convert(MLTETSt)) ) or 10
    else Validate MQCL_Out_TSpec;
 +1 Validate MQCL_Start;
}

State MQCL_QCLI_M_Recover {
   Depending on (Shutdown) { Validate MQCL_Shutdown; }

 +1  { nl_error( 2, "QCLI_M reporting error status 0x%04X", QCLI_M_s ); }
 +1  > QCLI_M Clear Errors
     Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 5
     else {
       nl_error( 2, "QCLI_M error did not clear: Resetting" );
       Validate MQCL_QCLI_M_Reset;
     }
     Validate MQCL_Start;
}

State MQCL_QCLI_M_Reset {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    { if ( ++num_MQCL_recovers > 20 ) {
        nl_error( 2,"Exceeded num_MQCL_recovers in QCLI_M_Reset: Invoking shutdown" );
        Validate MQCL_Fail;
      }
    }
 +1 > MINI QCLI Reset On
    > MINI QCLI Reset Off
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCL_QCLI_M_Reset;
    { ci_sendfcmd( 0, "Select QCLI_M Waveform Number %d\n", QCLI_M_Wave );
      Validate MQCL_Start;
    }
}

State MQCL_Stop {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
 +1 > QCLI_M Stop
    Hold until ( !(QCLI_M_s & 0x1000)) or 2
    else Validate MQCL_Stop_Reset;
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in MQCL_Stop" ); }
    Validate MQCL_Idle;
}

State MQCL_Stop_Reset {
    > MINI QCLI Reset On
 +1 > MINI QCLI Reset Off
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else > QCLI_M clear errors
    Hold until ( (QCLI_M_s & 0x3938) == 0 ) or 2
    else Validate MQCL_Stop_Reset;
    { ci_sendfcmd( 0, "Select QCLI_M Waveform Number %d\n", QCLI_M_Wave );
      Validate MQCL_Idle;
    }
}

#Running Waveforms

State MQCL_SelectWaveandRun {
    Depending on (Shutdown) { Validate MQCL_Shutdown; }
    > SSP_M Stop
    Hold until ( SSP_M_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in M3Df_800Hz" ); }
    > QCLI_M Stop
    Hold until ( !(QCLI_M_s & 0x1000) ) or 2
    else Validate MQCL_SelectWaveandRun_Reset;
 +1 > MINI Set Laser TEC Temp Setpoint 1.65
 +1 > MINI Laser TEC On
 +5 > Select QCLI_M Waveform M3Df_800Hz
 +2 Validate MQCL_Start;
}

State MQCL_SelectWaveandRun_Reset {
    > MINI QCLI Reset On
 +1 > MINI QCLI Reset Off
    Hold until ( !(QCLI_M_s & 0x1000) ) or 2
    else Validate MQCL_SelectWaveandRun_Reset;
    Validate MQCL_SelectWaveandRun;
}

#----------------------------------------------------------------
# Partition 7: CO2 Laser Control 4.3um QCL ICOS
#----------------------------------------------------------------
Partition

%{
 int num_CQCL_recovers=0;
 #define C_LOW_CURRENT 0.02
 #define CQCL_TEMP_LIMIT 1.3
 #define CQCL_TEMP_OK(x,y) (x > CQCL_TEMP_LIMIT && fabs(x - y) < 0.2)
%}

# CO2 Starting and Stopping

State CQCL_Init {
  +1  > SSP_C Stop
  +1  > QCLI_C Stop
      Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
      else > QCLI_C clear errors
      Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
      else Validate CQCL_Stop_Reset;
      Validate CQCL_Idle;
}

State CQCL_Idle {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
}

State CQCL_Start {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    Hold until ( SSP_C_Status == SSP_STATUS_READY )
    or 2 else {
      nl_error( 2, "SSP_C Not Ready in CQCL_Start" );
      Validate CQCL_SSP_C_Recover;
    }
    Hold until ( CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) ) or 10
    else Validate CQCL_Out_TSpec;
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 5
    else Validate CQCL_QCLI_C_Recover;
 +1 > SSP_C Start
    Hold until ( SSP_C_Status == SSP_STATUS_ARMED )
    or 20 else {
      nl_error( 2, "Not Armed in CQCL_Start" );
      Validate CQCL_SSP_C_Recover;
    }
    > QCLI_C Run
    Hold until ( SSP_C_Status == SSP_STATUS_TRIG && convert(CLasI) > C_LOW_CURRENT ) or 20
    #Hold until ( SSP_C_Status == SSP_STATUS_TRIG ) or 20
    else Validate CQCL_SSP_C_Recover;
    { num_CQCL_recovers = 0; }
    Validate CQCL_Watch;
}

State CQCL_Watch NoLog {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    { if ( SSP_C_Status == SSP_STATUS_READY ) {
        nl_error( 2, "SSP_C Went Ready Spontaneously" );
        Validate CQCL_SSP_C_Recover;
      }
    }
         # convert(HNano_I) < C_LOW_CURRENT ||
    hold until ( SSP_C_Status != SSP_STATUS_TRIG ||
         !CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) ||
	 convert(CLasI) <= C_LOW_CURRENT );
    hold until ( SSP_C_Status == SSP_STATUS_TRIG &&
         CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) &&
	 convert(CLasI) >= C_LOW_CURRENT ) or 2
    else Validate CQCL_Watch_Recover;
    Validate CQCL_Watch;
}

State CQCL_Watch_Recover {
    {
      if (!CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)))
        Validate CQCL_Out_TSpec;
      else if (convert(CLasI) <= C_LOW_CURRENT)
        Validate CQCL_Out_Spec;
      else if (SSP_C_Status != SSP_STATUS_TRIG)
        Validate CQCL_SSP_C_Recover;
      else Validate CQCL_Watch;
    }
}

State CQCL_SSP_C_Recover NoLog {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
    { if ( ++num_CQCL_recovers > 20 ) {
        nl_error( 2, "Exceeded num_CQCL_recovers. Trying reset" );
        num_CQCL_recovers = 0;
        Validate CQCL_QCLI_C_Reset;
      }
    }
    Hold until ( SSP_C_Status == SSP_STATUS_READY ) or 10
    else Validate CQCL_SSP_C_Not_Talking;
 +2 > QCLI_C Stop
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else > QCLI_C clear errors
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else Validate CQCL_QCLI_C_Reset;
    Validate CQCL_Start;
}

State CQCL_SSP_C_Not_Talking {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
    { if ( ++num_CQCL_recovers > 20 ) Validate CQCL_Fail; }
    Hold until ( SSP_C_Status == SSP_STATUS_READY ) or 10
    else Validate CQCL_SSP_C_Not_Talking;
    Validate CQCL_SSP_C_Recover;
}

State CQCL_Fail {
    > Log Laser CQCL Has Failed
 +1 Validate CQCL_Shutdown;
}

State CQCL_Shutdown {
    > SSP_C Stop
 +1 > QCLI_C Stop
    Hold until ( !(QCLI_C_s & 0x1000) ) or 2
    else Validate CQCL_Shutdown_Reset;
    > Log Laser CQCL Has Shutdown
    > CO2 Laser TEC Off
    Validate CQCL_Is_Shutdown;
}

State CQCL_Shutdown_Reset {
    > CO2 QCLI Reset On
 +1 > CO2 QCLI Reset Off
    Validate CQCL_Shutdown;
}

State CQCL_Is_Shutdown {}

State CQCL_Out_Spec {
    > QCLI_C Stop
 +1 Validate CQCL_QCLI_C_Recover;
}

State CQCL_Out_TSpec {
    > QCLI_C Stop
 +1 > CO2 Laser TEC Off
 +5 > CO2 Laser TEC On
    Hold until ( CQCL_TEMP_OK(convert(CLTE4R3T),convert(CLTETSt)) ) or 10
    else Validate CQCL_Out_TSpec;
 +1 Validate CQCL_Start;
}

State CQCL_QCLI_C_Recover {
   Depending on (Shutdown) { Validate CQCL_Shutdown; }

 +1  { nl_error( 2, "QCLI_C reporting error status 0x%04X", QCLI_C_s ); }
 +1  > QCLI_C Clear Errors
     Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 5
     else {
       nl_error( 2, "QCLI_C error did not clear: Resetting" );
       Validate CQCL_QCLI_C_Reset;
     }
     Validate CQCL_Start;
}

State CQCL_QCLI_C_Reset {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    { if ( ++num_CQCL_recovers > 20 ) {
        nl_error( 2,"Exceeded num_CQCL_recovers in QCLI_C_Reset: Invoking shutdown" );
        Validate CQCL_Fail;
      }
    }
 +1 > CO2 QCLI Reset On
    > CO2 QCLI Reset Off
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else > QCLI_C clear errors
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else Validate CQCL_QCLI_C_Reset;
    { ci_sendfcmd( 0, "Select QCLI_C Waveform Number %d\n", QCLI_C_Wave );
      Validate CQCL_Start;
    }
}

State CQCL_Stop {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
 +1 > QCLI_C Stop
    Hold until ( !(QCLI_C_s & 0x1000)) or 2
    else Validate CQCL_Stop_Reset;
    Hold until ( SSP_C_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in CQCL_Stop" ); }
    Validate CQCL_Idle;
}

State CQCL_Stop_Reset {
    > CO2 QCLI Reset On
 +1 > CO2 QCLI Reset Off
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else > QCLI_C clear errors
    Hold until ( (QCLI_C_s & 0x3938) == 0 ) or 2
    else Validate CQCL_Stop_Reset;
    { ci_sendfcmd( 0, "Select QCLI_C Waveform Number %d\n", QCLI_C_Wave );
      Validate CQCL_Idle;
    }
}

#Running Waveforms

State CQCL_SelectWaveandRun {
    Depending on (Shutdown) { Validate CQCL_Shutdown; }
    > SSP_C Stop
    Hold until ( SSP_C_Status == SSP_STATUS_READY ) or 5
    else { nl_error( 2, "Not Ready in C2Cd_800Hz" ); }
    > QCLI_C Stop
    Hold until ( !(QCLI_C_s & 0x1000) ) or 2
    else Validate CQCL_SelectWaveandRun_Reset;
 +1 > CO2 Set Laser TEC Temp Setpoint 1.45
 +1 > CO2 Laser TEC On
 +5 > Select QCLI_C Waveform C2Cd_800Hz
 +2 Validate CQCL_Start;
}

State CQCL_SelectWaveandRun_Reset {
    > CO2 QCLI Reset On
 +1 > CO2 QCLI Reset Off
    Hold until ( !(QCLI_C_s & 0x1000) ) or 2
    else Validate CQCL_SelectWaveandRun_Reset;
    Validate CQCL_SelectWaveandRun;
}
#----------------------------------------------------------------
# Partition 8: Calibration Logic 
#----------------------------------------------------------------
Partition

State Calibrate_Logic {
  Depending on (1Hz) {
    if ( MINI_Ready_To_Calibrate == 1 )
      Validate Calibrate_MINI; 
    else if ( CO2_Ready_To_Calibrate == 1 )
      Validate Calibrate_CO2;
  }
}

State Calibrate_MINI {
{ Cell_Ctrl = 0; }  
   +1 > MINI Pressure Reg Off 
   +1 > MINI Gas Valve Open
   +1 Validate GasDeck_PI_Init;
+2:00 Validate GasDeck_Close;
      { MINI_Ready_To_Calibrate = 0; }
   +1 Validate Calibrate_Logic;
}

State Calibrate_CO2 {
{ Cell_Ctrl = 1; }
   +1 > CO2 Pressure Reg Off 
   +1 > CO2 Gas Valve Open
   +1 Validate GasDeck_PI_Init;
+2:00 Validate GasDeck_Close;
      { CO2_Ready_To_Calibrate = 0; }
   +1 Validate Calibrate_Logic;
}


#----------------------------------------------------------------
# Partition 9: Gas Deck Pressure Control
#----------------------------------------------------------------
Partition

%{
  double P_sum = 0., Gp, Gi;
  int Cell_Ctrl;
  #define US_CAST(x) ((unsigned short)(x))
  #define MAX_CAL_BITS 2047
  #include <math.h> /* for fabs */
%}

State GasDeck_Init {
     > Gas Deck Flow Controller Closed On
     > Gas Deck Valve Closed
     > MINI Gas Valve Closed
     > CO2 Gas Valve Closed
 +1  Validate GasDeck_Idle;
}

State GasDeck_Idle {
}

State GasDeck_PI_Init {
  { P_sum = 0; Gp = 1; Gi = 0.5; }
     > Gas Deck Set Gas Flow Setpoint 0
     > Gas Deck Flow Controller Closed Off
  +1 > Gas Deck Valve Open
  +2 Validate GasDeck_PI;
}

State GasDeck_PI {
  { double P, P_set, P_diff, dstep; 
    unsigned short ustep;
    P = Cell_Ctrl ? convert(CCelP):convert(MCelP);
    P_set = Cell_Ctrl ? convert(CCelPSt):convert(MCelPSt);
    P_diff = P_set - P;
    P_sum += P_diff * Gi;
    if ( P_sum > MAX_CAL_BITS )
      P_sum = MAX_CAL_BITS;
    else if ( P_sum < 0 ) P_sum = 0;
    dstep = P_diff * Gp + P_sum;
    if (dstep<0) dstep = 0;
    else if (dstep > MAX_CAL_BITS) dstep = MAX_CAL_BITS;
    ustep = US_CAST(dstep);
    ci_sendfcmd(2, "Gas Deck Set Gas Flow Setpoint %u\n", ustep);
  }
}

#State GasDeck_Fill_Cell {
#  +1 > Bench Flow 1 Setpoint 400
#  Hold Until ( convert(HCInP) > convert(PV_SetP)-10 ) or 5:00;
#     > Bench Flow 1 Setpoint 100
#  Hold Until ( convert(HCInP) > convert(PV_SetP)-2 ) or 5:00;
#     > Bench Flow 1 Setpoint 50
#  Hold Until ( convert(HCInP) > convert(PV_SetP)-0.2 ) or 5:00;
#     > Bench Flow 1 Setpoint 0
#  Validate Bench_Idle;
#}

State GasDeck_Close {
     > Gas Deck Flow Controller Closed On
     > Gas Deck Valve Closed
     > MINI Gas Valve Closed
     > CO2 Gas Valve Closed
  +1 Validate GasDeck_Idle;
}

#----------------------------------------------------------------
# Partition 10: Pump Control
#----------------------------------------------------------------
Partition
%{
 #define PUMP_TEMP_HOT 50
 #define PUMP_TEMP_OK(x) (x < PUMP_TEMP_HOT)
%}

State Pump_Init {
    > CO2 Exhaust Valve Closed
    > MINI Exhaust Valve Closed
 +1 > CO2 Scroll Pump Off
 +1 > MINI Scroll Pump Off
 +1 > Inverter Arm On
    Hold until (InvPwrS == 1) or 5
    else Validate Pump_Inverter_Off;
    Depending on (Shutdown) { Validate Pump_Shutdown; }
    Depending on (Record) { Validate Pump_Start; }

}

State Pump_Start {
    Depending on (Shutdown) { Validate Pump_Shutdown; }
    { if (!InvPwrS) Validate Pump_Inverter_Off; } 
    Hold until valid (Pump_Cool_Watch);
 +5 > CO2 Scroll Pump On
 +10 > MINI Scroll Pump On
 +10 > CO2 Exhaust Valve Open
 +1 > MINI Exhaust Valve Open
    Validate Pump_Watch;
}

State Pump_Watch Nolog {
    Depending on (Shutdown) { Validate Pump_Shutdown; }
    { if (!InvPwrS) Validate Pump_Inverter_Off; } 
    hold until ( !PUMP_TEMP_OK(convert(CPmpT)) ||
         !PUMP_TEMP_OK(convert(MPmpT)) );
    hold until ( PUMP_TEMP_OK(convert(CPmpT)) &&
         PUMP_TEMP_OK(convert(MPmpT)) ) or 5
    else Validate Pump_Hot;
    Validate Pump_Watch;
}

State Pump_Hot {
    Depending on (Shutdown) { Validate Pump_Shutdown; }
    { if (!InvPwrS) Validate Pump_Inverter_Off; } 
    > CO2 Exhaust Valve Closed
    > MINI Exhaust Valve Closed
 +1 > CO2 Scroll Pump Off
 +1 > MINI Scroll Pump Off
    Hold until ( PUMP_TEMP_OK(convert(CPmpT)+5) &&
         PUMP_TEMP_OK(convert(MPmpT)+5) );
    Validate Pump_Start;
}

State Pump_Inverter_Off {
    Depending on (Shutdown) { Validate Pump_Shutdown; }
    > Inverter Power Off
 +1 > CO2 Exhaust Valve Closed
    > MINI Exhaust Valve Closed
 +1 > CO2 Scroll Pump Off
 +1 > MINI Scroll Pump Off
+10 > Inverter Power On
 +5 Hold until (InvPwrS == 1) or 5
    else Validate Pump_Inverter_Off;
    Validate Pump_Start;
}

State Pump_Shutdown {
    > CO2 Exhaust Valve Closed
 +1 > MINI Exhaust Valve Closed
 +1 > CO2 Scroll Pump Off
 +1 > MINI Scroll Pump Off
 +1 Validate Pump_Off;
}

State Pump_Off {
    Hold until valid (Pump_Cool_Is_Shutdown);
    > Inverter Arm Off
    Validate Pump_Is_Shutdown;
}

State Pump_Is_Shutdown {}


# -----------------------------------------------------------------------------
# Partition 11: Pump Cooling Control
# -----------------------------------------------------------------------------
Partition

%{
 #define BATH_TEMP_COLD 25
 #define PUMP_TEMP_COLD 35
 #define BATH_TEMP_OK(x) (x > BATH_TEMP_COLD)
 #define PUMP_COLD_OK(x) (x < PUMP_TEMP_COLD)
%}

State Pump_Cool_Init {
    > Coolant Pump Off
    > Coolant Divert Off
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    Depending on (Record) { Validate Pump_Cool_Start; }
}

State Pump_Cool_Start {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    Hold until (InvPwrS == 1);
 +1 > Coolant Pump On
 +1 Validate Pump_Cool_Watch;
}

State Pump_Cool_Watch Nolog {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    { if (!InvPwrS) Validate Pump_Cool_Inverter_Off; } 
 +1 hold until ( !BATH_TEMP_OK(convert(WTnkT)) );
 +1 hold until ( BATH_TEMP_OK(convert(WTnkT)) ) or 5
    else Validate Pump_Cool_Cold;
    Validate Pump_Watch;
}

State Pump_Cool_Cold {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    { if (!InvPwrS) Validate Pump_Cool_Inverter_Off; } 
    > Coolant Divert On
    Hold until ( BATH_TEMP_OK(convert(WTnkT)-5) );
 +1 > Coolant Divert Off
 +1 Validate Pump_Cool_Watch;
}

State Pump_Cool_Inverter_Off {
    Depending on (Shutdown) { Validate Pump_Cool_Shutdown; }
    > Coolant Pump Off
 +1 > Coolant Divert Off
 +5 Validate Pump_Cool_Start;
}

State Pump_Cool_Shutdown {
   +1 Hold until valid (Pump_Off);
   +1 hold until ( PUMP_COLD_OK(convert(CPmpT)) &&
         PUMP_COLD_OK(convert(MPmpT)) );
   +1 > Coolant Pump Off
   +1 Validate Pump_Cool_Is_Shutdown;
}

State Pump_Cool_Is_Shutdown {}


# -----------------------------------------------------------------------------
# Partition 12: Luggage Bay Temperature Control
# Throttle Valve Control and Space Heater Control
# -----------------------------------------------------------------------------
Partition

State LuggageBay_TCtrl_Init {
} 
# State Throttle_Standby {
#   +5
#   depending on (OFF_GROUND) { Validate Throttle_init; }
#   depending on (IN_AIR) { Validate Throttle_init; }
# }
# 
# Space heater control should get moved with throttle to luggage bay heater control
#  +10 > HK Set Space Heater Temp Setpoint 1.25
#   +1 > Space Heater Controller On
#-------------------
# # INITIALIZE
# State Throttle_init     {
#        > drive Throttle Valve in 48000
#   +2   > drive Throttle Valve out 10000
#   +5   > drive Throttle Valve to 15000
#   +5   Validate Throttle_scan;
# }
# 
# # RUN & SCAN
# State Throttle_scan {
#         depending on (ON_GROUND) { Validate Throttle_shut; }
#         depending on (Shutdown) { Validate Throttle_shut; }
#         > drive Throttle Valve to 47000
#         Hold until (SW_St == SWS_TIMEWARP) or 34:00;
#         > drive Throttle Valve to 40000
#   +2:00 > drive Throttle Valve to 32500
#   +2:00 > drive Throttle Valve to 25000
#   +2:00 Validate Throttle_scan;
# }
# 
# State Throttle_shut {
#   > drive Throttle Valve in 48000
#   > drive Throttle Valve out 20
# }


# -----------------------------------------------------------------------------
# Partition 13: Mini Methane Temperature Control
# -----------------------------------------------------------------------------
Partition
%{
  #define TEMP_OK(x,y) ( y-x < 0.5 )
%}

State MTControl_Init {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
}

State MTControl_Start {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
    +1 > MINI Set LPV External TEC Setpoint 1.25
    +1 > MINI Set DPV Temp Setpoint 1.25
    +1 > MINI Set Cell Temp Setpoint 1.25
    +1 > MINI Cell Htr Ctl On
   +10 > MINI Detector PV Htr Ctl On
   +10 > MINI LPV TEC On
   +1  Validate MTControl_Watch;
}

State MTControl_Watch NoLog {
Depending on (Shutdown) { Validate MTControl_Shutdown; }
    Hold until (!TEMP_OK(convert(MLPVTSt),convert(MLPVCT))
        || !TEMP_OK(convert(MDPVTSt),convert(MDPVCT))
        || !TEMP_OK(convert(MCelTSt),convert(MCelCT)) );

    Hold until (TEMP_OK(convert(MLPVTSt),convert(MLPVCT))
        && TEMP_OK(convert(MDPVTSt),convert(MDPVCT))
        && TEMP_OK(convert(MCelTSt),convert(MCelCT)) ) or 2
    else Validate MTControl_Not_OK;

    Validate MTControl_Watch;
}

State MTControl_Not_OK {
    Depending on (Shutdown) { Validate MTControl_Shutdown; }

    hold until (TEMP_OK(convert(MLPVTSt),convert(MLPVCT)))
    or 1 else > MINI LPV TEC Off

    hold until (TEMP_OK(convert(MDPVTSt),convert(MDPVCT)))
    or 1 else > MINI Detector PV Htr Ctl Off

    hold until (TEMP_OK(convert(MCelTSt),convert(MCelCT)))
    or 1 else > MINI Cell Htr Ctl Off

   +10 > MINI Cell Htr Ctl On
    +1 > MINI Detector PV Htr Ctl On
    +1 > MINI LPV TEC On
    +1 Validate MTControl_Watch;
}

State MTControl_Shutdown {
    > MINI Cell Htr Ctl Off
    > MINI Detector PV Htr Ctl Off
    > MINI LPV TEC Off
}

# -----------------------------------------------------------------------------
# Partition 14: CO2 Temperature Control
# -----------------------------------------------------------------------------
Partition

State CTControl_Init {
  Depending on (Shutdown) { Validate CTControl_Shutdown; }
}

State CTControl_Start {
Depending on (Shutdown) { Validate CTControl_Shutdown; }
    +1 > CO2 Set LPV Temp Setpoint 1.25
    +1 > CO2 Set Cell Temp Setpoint 1.25
    +1 > CO2 Cell Htr Ctl On
   +10 > CO2 Laser PV Htr Ctl On
   +1  Validate CTControl_Watch;
}

State CTControl_Watch NoLog {
  Depending on (Shutdown) { Validate CTControl_Shutdown; }
    Hold until (!TEMP_OK(convert(CLPVTSt),convert(CLPVCT)) ||
        !TEMP_OK(convert(CCelTSt),convert(CCelCT)) );
    Hold until (TEMP_OK(convert(CLPVTSt),convert(CLPVCT)) &&
        TEMP_OK(convert(CCelTSt),convert(CCelCT)) ) or 2
    else Validate CTControl_Not_OK;
    Validate CTControl_Watch;
}

State CTControl_Not_OK {
    Depending on (Shutdown) { Validate CTControl_Shutdown; }

    hold until (TEMP_OK(convert(CLPVTSt),convert(CLPVCT)))
    or 1 else > CO2 Laser PV Htr Ctl Off

    hold until (TEMP_OK(convert(CCelTSt),convert(CCelCT)))
    or 1 else > CO2 Cell Htr Ctl Off

   +10 > CO2 Cell Htr Ctl On
    +1 > CO2 Laser PV Htr Ctl On
    +1 Validate CTControl_Watch;
}

State CTControl_Shutdown {
    > CO2 Cell Htr Ctl Off
    > CO2 Laser PV Htr Ctl Off
}

# -----------------------------------------------------------------------------
# Partition 15: Realtime File Input
# -----------------------------------------------------------------------------
Partition
State ReadFile_idle {}

State ReadFile "HCI.tmas" {
  +5 Validate ReadFile_idle;
}


#---------------------------------------------------------------
# Partition 16: ReadFile Conditions
#---------------------------------------------------------------
# Summary:
#   RFCond_Idle: Nothing
#   RFCond_TimeWarp: Wait for Time Warp
#---------------------------------------------------------------
Partition
State RFCond_Idle {}

State RFCond_TimeWarp {
  Hold until ( SWStat == SWS_TIMEWARP );
  Resume ReadFile;
  Validate RFCond_Idle;
}


#---------------------------------------------------------------
# Partition 17: Analog Input Monitoring
#---------------------------------------------------------------
Partition
%{
  AI_T30K Last_PC__T = 0;
  static int PC__T_static_count = 0;
  static int PC__T_delta_count = 0;
  static int AI_Reset_count = 0;
  static int AI_Reset_limit = 0;
%}
State AI_Watch {
    { if ( PC__T == Last_PC__T ) {
	if ( ++PC__T_static_count >= 5 ) {
	  msg(2, "PC__T has not changed in 5 seconds");
	  PC__T_delta_count = 0;
	  Validate AI_Reset;
	}
      } else {
	Last_PC__T = PC__T;
	PC__T_static_count = 0;
	if ( ++PC__T_delta_count > 5 ) {
	  PC__T_delta_count = 0;
	  AI_Reset_count = 0;
	}
      }
    }
}

State AI_Reset {
      > AI Reset
  +1  > AI Double Convert Row Zero
      { if ( AI_Reset_limit > 0 &&
	     ++AI_Reset_count >= AI_Reset_limit ) {
	  msg(2,"AI Max Reset Count Reached");
	  Validate AI_Fail;
	}
      }
      Hold until ( PC__T != Last_PC__T ) OR 5
      else Validate AI_Reset;
      Validate AI_Watch;
}

State AI_Fail {}
